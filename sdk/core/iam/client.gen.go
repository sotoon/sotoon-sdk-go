// Package iam provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package iam

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AcceptInvitationWithBody request with any body
	AcceptInvitationWithBody(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AcceptInvitation(ctx context.Context, token string, body AcceptInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthTokenWithCredWithBody request with any body
	CreateAuthTokenWithCredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthTokenWithCred(ctx context.Context, body CreateAuthTokenWithCredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthTokenWithChallengeWithBody request with any body
	CreateAuthTokenWithChallengeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuthTokenWithChallenge(ctx context.Context, body CreateAuthTokenWithChallengeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDetailedGroups request
	ListDetailedGroups(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDetailedGroup request
	GetDetailedGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDetailedServiceUsers request
	ListDetailedServiceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDetailedServiceUser request
	GetDetailedServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDetailedWorkspaceUsers request
	ListDetailedWorkspaceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDetailedWorkspaceUser request
	GetDetailedWorkspaceUser(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIamV1ApiV1Healthz request
	GetIamV1ApiV1Healthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThirdPartyAccessTokenWithBody request with any body
	GetThirdPartyAccessTokenWithBody(ctx context.Context, organizationUUID string, thirdPartyUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetThirdPartyAccessToken(ctx context.Context, organizationUUID string, thirdPartyUUID string, body GetThirdPartyAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePasswordWithBody request with any body
	ChangePasswordWithBody(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePassword(ctx context.Context, token string, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCanUserWithBody request with any body
	BulkCanUserWithBody(ctx context.Context, userUUID string, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCanUser(ctx context.Context, userUUID string, workspaceUUID string, body BulkCanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableUserOtp request
	DisableUserOtp(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOtpStatus request
	GetUserOtpStatus(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableUserOtpWithBody request with any body
	EnableUserOtpWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableUserOtp(ctx context.Context, userUUID string, body EnableUserOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPublicKeys request
	ListUserPublicKeys(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserPublicKeyWithBody request with any body
	CreateUserPublicKeyWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserPublicKey(ctx context.Context, userUUID string, body CreateUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserPublicKey request
	DeleteUserPublicKey(ctx context.Context, userUUID string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserTokens request
	ListUserTokens(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserTokenWithBody request with any body
	CreateUserTokenWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserToken(ctx context.Context, userUUID string, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserToken request
	DeleteUserToken(ctx context.Context, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserWorkspaces request
	ListUserWorkspaces(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBackupKeys request
	ListBackupKeys(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackupKeyWithBody request with any body
	CreateBackupKeyWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackupKey(ctx context.Context, workspaceUUID string, body CreateBackupKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackupKey request
	DeleteBackupKey(ctx context.Context, workspaceUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, workspaceUUID string, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, workspaceUUID string, groupUUID string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddRolesToGroup request
	BulkAddRolesToGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddServiceUsersToGroupWithBody request with any body
	BulkAddServiceUsersToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddServiceUsersToGroup(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddServiceUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddUsersToGroupWithBody request with any body
	BulkAddUsersToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddUsersToGroup(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupRoles request
	ListGroupRoles(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupServiceUsers request
	ListGroupServiceUsers(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveServiceUserFromGroup request
	RemoveServiceUserFromGroup(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddServiceUserToGroupWithBody request with any body
	AddServiceUserToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddServiceUserToGroup(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, body AddServiceUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupUsers request
	ListGroupUsers(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromGroup request
	RemoveUserFromGroup(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToGroupWithBody request with any body
	AddUserToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToGroup(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InviteUsersToWorkspaceWithBody request with any body
	InviteUsersToWorkspaceWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InviteUsersToWorkspace(ctx context.Context, workspaceUUID string, body InviteUsersToWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceUserKiseKeys request
	ListServiceUserKiseKeys(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoles request
	ListRoles(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRole request
	CreateRole(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddRulesToRoleWithBody request with any body
	BulkAddRulesToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddRulesToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddRulesToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddServiceUsersToRoleWithBody request with any body
	BulkAddServiceUsersToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddServiceUsersToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddServiceUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddUsersToRoleWithBody request with any body
	BulkAddUsersToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddUsersToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRoleFromGroup request
	RemoveRoleFromGroup(ctx context.Context, workspaceUUID string, roleUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRoleRules request
	ListRoleRules(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRuleFromRole request
	RemoveRuleFromRole(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRuleToRoleWithBody request with any body
	AddRuleToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRuleToRole(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, body AddRuleToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceUsersRoleBindings request
	ListServiceUsersRoleBindings(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRoleFromServiceUser request
	RemoveRoleFromServiceUser(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceUserRoleBinding request
	GetServiceUserRoleBinding(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToServiceUserWithBody request with any body
	AssignRoleToServiceUserWithBody(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignRoleToServiceUser(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, body AssignRoleToServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsersRoleBindings request
	ListUsersRoleBindings(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRoleFromUser request
	RemoveRoleFromUser(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserRoleBinding request
	GetUserRoleBinding(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignRoleToUserWithBody request with any body
	AssignRoleToUserWithBody(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssignRoleToUser(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRules request
	ListRules(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleWithBody request with any body
	CreateRuleWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, workspaceUUID string, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule request
	GetRule(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleWithBody request with any body
	UpdateRuleWithBody(ctx context.Context, workspaceUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, workspaceUUID string, ruleUUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRuleRoles request
	ListRuleRoles(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceUsers request
	ListServiceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceUserWithBody request with any body
	CreateServiceUserWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceUser(ctx context.Context, workspaceUUID string, body CreateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceUser request
	DeleteServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceUserWithBody request with any body
	UpdateServiceUserWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, body UpdateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceUserKiseKeyWithBody request with any body
	CreateServiceUserKiseKeyWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceUserKiseKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceUserKiseKey request
	DeleteServiceUserKiseKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceUserPublicKeys request
	ListServiceUserPublicKeys(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceUserPublicKeyWithBody request with any body
	CreateServiceUserPublicKeyWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceUserPublicKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceUserPublicKey request
	DeleteServiceUserPublicKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceUserTokens request
	ListServiceUserTokens(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceUserTokenWithBody request with any body
	CreateServiceUserTokenWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceUserToken(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceUserToken request
	DeleteServiceUserToken(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServices request
	ListServices(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkRefreshThirdPartyTokensWithBody request with any body
	BulkRefreshThirdPartyTokensWithBody(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkRefreshThirdPartyTokens(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, body BulkRefreshThirdPartyTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkspaceUsers request
	ListWorkspaceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromWorkspace request
	RemoveUserFromWorkspace(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllowUserWithBody request with any body
	AllowUserWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AllowUser(ctx context.Context, workspaceUUID string, userUUID string, body AllowUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserKiseKeys request
	ListUserKiseKeys(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserKiseKeyWithBody request with any body
	CreateUserKiseKeyWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserKiseKey(ctx context.Context, workspaceUUID string, userUUID string, body CreateUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserKiseKey request
	DeleteUserKiseKey(ctx context.Context, workspaceUUID string, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendUserWithBody request with any body
	SuspendUserWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SuspendUser(ctx context.Context, workspaceUUID string, userUUID string, body SuspendUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenIdTokenWithBody request with any body
	GetOpenIdTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetOpenIdToken(ctx context.Context, body GetOpenIdTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AcceptInvitationWithBody(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInvitationRequestWithBody(c.Server, token, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptInvitation(ctx context.Context, token string, body AcceptInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptInvitationRequest(c.Server, token, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithCredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenWithCredRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithCred(ctx context.Context, body CreateAuthTokenWithCredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenWithCredRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithChallengeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenWithChallengeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthTokenWithChallenge(ctx context.Context, body CreateAuthTokenWithChallengeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthTokenWithChallengeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDetailedGroups(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDetailedGroupsRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDetailedGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDetailedGroupRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDetailedServiceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDetailedServiceUsersRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDetailedServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDetailedServiceUserRequest(c.Server, workspaceUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDetailedWorkspaceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDetailedWorkspaceUsersRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDetailedWorkspaceUser(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDetailedWorkspaceUserRequest(c.Server, workspaceUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIamV1ApiV1Healthz(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIamV1ApiV1HealthzRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThirdPartyAccessTokenWithBody(ctx context.Context, organizationUUID string, thirdPartyUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThirdPartyAccessTokenRequestWithBody(c.Server, organizationUUID, thirdPartyUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThirdPartyAccessToken(ctx context.Context, organizationUUID string, thirdPartyUUID string, body GetThirdPartyAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThirdPartyAccessTokenRequest(c.Server, organizationUUID, thirdPartyUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordWithBody(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequestWithBody(c.Server, token, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePassword(ctx context.Context, token string, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequest(c.Server, token, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCanUserWithBody(ctx context.Context, userUUID string, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCanUserRequestWithBody(c.Server, userUUID, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCanUser(ctx context.Context, userUUID string, workspaceUUID string, body BulkCanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCanUserRequest(c.Server, userUUID, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableUserOtp(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableUserOtpRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOtpStatus(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOtpStatusRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableUserOtpWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableUserOtpRequestWithBody(c.Server, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableUserOtp(ctx context.Context, userUUID string, body EnableUserOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableUserOtpRequest(c.Server, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPublicKeys(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPublicKeysRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserPublicKeyWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserPublicKeyRequestWithBody(c.Server, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserPublicKey(ctx context.Context, userUUID string, body CreateUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserPublicKeyRequest(c.Server, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserPublicKey(ctx context.Context, userUUID string, resourceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserPublicKeyRequest(c.Server, userUUID, resourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserTokens(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserTokensRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserTokenWithBody(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserTokenRequestWithBody(c.Server, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserToken(ctx context.Context, userUUID string, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserTokenRequest(c.Server, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserToken(ctx context.Context, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTokenRequest(c.Server, userUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserWorkspaces(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserWorkspacesRequest(c.Server, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBackupKeys(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBackupKeysRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupKeyWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupKeyRequestWithBody(c.Server, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupKey(ctx context.Context, workspaceUUID string, body CreateBackupKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupKeyRequest(c.Server, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackupKey(ctx context.Context, workspaceUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupKeyRequest(c.Server, workspaceUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, workspaceUUID string, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, workspaceUUID, groupUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, workspaceUUID string, groupUUID string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, workspaceUUID, groupUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddRolesToGroup(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddRolesToGroupRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddServiceUsersToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddServiceUsersToGroupRequestWithBody(c.Server, workspaceUUID, groupUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddServiceUsersToGroup(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddServiceUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddServiceUsersToGroupRequest(c.Server, workspaceUUID, groupUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddUsersToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddUsersToGroupRequestWithBody(c.Server, workspaceUUID, groupUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddUsersToGroup(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddUsersToGroupRequest(c.Server, workspaceUUID, groupUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupRoles(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupRolesRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupServiceUsers(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupServiceUsersRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveServiceUserFromGroup(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveServiceUserFromGroupRequest(c.Server, workspaceUUID, groupUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddServiceUserToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddServiceUserToGroupRequestWithBody(c.Server, workspaceUUID, groupUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddServiceUserToGroup(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, body AddServiceUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddServiceUserToGroupRequest(c.Server, workspaceUUID, groupUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupUsers(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupUsersRequest(c.Server, workspaceUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromGroup(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromGroupRequest(c.Server, workspaceUUID, groupUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroupWithBody(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequestWithBody(c.Server, workspaceUUID, groupUUID, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToGroup(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToGroupRequest(c.Server, workspaceUUID, groupUUID, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsersToWorkspaceWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersToWorkspaceRequestWithBody(c.Server, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InviteUsersToWorkspace(ctx context.Context, workspaceUUID string, body InviteUsersToWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInviteUsersToWorkspaceRequest(c.Server, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceUserKiseKeys(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceUserKiseKeysRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoles(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRolesRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, workspaceUUID, roleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, workspaceUUID, roleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddRulesToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddRulesToRoleRequestWithBody(c.Server, workspaceUUID, roleUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddRulesToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddRulesToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddRulesToRoleRequest(c.Server, workspaceUUID, roleUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddServiceUsersToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddServiceUsersToRoleRequestWithBody(c.Server, workspaceUUID, roleUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddServiceUsersToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddServiceUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddServiceUsersToRoleRequest(c.Server, workspaceUUID, roleUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddUsersToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddUsersToRoleRequestWithBody(c.Server, workspaceUUID, roleUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkAddUsersToRole(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddUsersToRoleRequest(c.Server, workspaceUUID, roleUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRoleFromGroup(ctx context.Context, workspaceUUID string, roleUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRoleFromGroupRequest(c.Server, workspaceUUID, roleUUID, groupUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRoleRules(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRoleRulesRequest(c.Server, workspaceUUID, roleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRuleFromRole(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRuleFromRoleRequest(c.Server, workspaceUUID, roleUUID, ruleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuleToRoleWithBody(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuleToRoleRequestWithBody(c.Server, workspaceUUID, roleUUID, ruleUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuleToRole(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, body AddRuleToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuleToRoleRequest(c.Server, workspaceUUID, roleUUID, ruleUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceUsersRoleBindings(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceUsersRoleBindingsRequest(c.Server, workspaceUUID, roleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRoleFromServiceUser(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRoleFromServiceUserRequest(c.Server, workspaceUUID, roleUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceUserRoleBinding(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceUserRoleBindingRequest(c.Server, workspaceUUID, roleUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToServiceUserWithBody(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToServiceUserRequestWithBody(c.Server, workspaceUUID, roleUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToServiceUser(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, body AssignRoleToServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToServiceUserRequest(c.Server, workspaceUUID, roleUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsersRoleBindings(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRoleBindingsRequest(c.Server, workspaceUUID, roleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRoleFromUser(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRoleFromUserRequest(c.Server, workspaceUUID, roleUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserRoleBinding(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRoleBindingRequest(c.Server, workspaceUUID, roleUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToUserWithBody(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToUserRequestWithBody(c.Server, workspaceUUID, roleUUID, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignRoleToUser(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignRoleToUserRequest(c.Server, workspaceUUID, roleUUID, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRules(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRulesRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, workspaceUUID string, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, workspaceUUID, ruleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleRequest(c.Server, workspaceUUID, ruleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, workspaceUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, workspaceUUID, ruleUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, workspaceUUID string, ruleUUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, workspaceUUID, ruleUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRuleRoles(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRuleRolesRequest(c.Server, workspaceUUID, ruleUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceUsersRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserWithBody(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserRequestWithBody(c.Server, workspaceUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUser(ctx context.Context, workspaceUUID string, body CreateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserRequest(c.Server, workspaceUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceUserRequest(c.Server, workspaceUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceUserWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceUserRequestWithBody(c.Server, workspaceUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceUser(ctx context.Context, workspaceUUID string, serviceUserUUID string, body UpdateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceUserRequest(c.Server, workspaceUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserKiseKeyWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserKiseKeyRequestWithBody(c.Server, workspaceUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserKiseKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserKiseKeyRequest(c.Server, workspaceUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceUserKiseKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceUserKiseKeyRequest(c.Server, workspaceUUID, serviceUserUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceUserPublicKeys(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceUserPublicKeysRequest(c.Server, workspaceUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserPublicKeyWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserPublicKeyRequestWithBody(c.Server, workspaceUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserPublicKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserPublicKeyRequest(c.Server, workspaceUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceUserPublicKey(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceUserPublicKeyRequest(c.Server, workspaceUUID, serviceUserUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceUserTokens(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceUserTokensRequest(c.Server, workspaceUUID, serviceUserUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserTokenWithBody(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserTokenRequestWithBody(c.Server, workspaceUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceUserToken(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceUserTokenRequest(c.Server, workspaceUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceUserToken(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceUserTokenRequest(c.Server, workspaceUUID, serviceUserUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServices(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicesRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkRefreshThirdPartyTokensWithBody(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkRefreshThirdPartyTokensRequestWithBody(c.Server, workspaceUUID, thirdPartyUUID, serviceUserUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkRefreshThirdPartyTokens(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, body BulkRefreshThirdPartyTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkRefreshThirdPartyTokensRequest(c.Server, workspaceUUID, thirdPartyUUID, serviceUserUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkspaceUsers(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkspaceUsersRequest(c.Server, workspaceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromWorkspace(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromWorkspaceRequest(c.Server, workspaceUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowUserWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowUserRequestWithBody(c.Server, workspaceUUID, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllowUser(ctx context.Context, workspaceUUID string, userUUID string, body AllowUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllowUserRequest(c.Server, workspaceUUID, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserKiseKeys(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserKiseKeysRequest(c.Server, workspaceUUID, userUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserKiseKeyWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserKiseKeyRequestWithBody(c.Server, workspaceUUID, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserKiseKey(ctx context.Context, workspaceUUID string, userUUID string, body CreateUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserKiseKeyRequest(c.Server, workspaceUUID, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserKiseKey(ctx context.Context, workspaceUUID string, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserKiseKeyRequest(c.Server, workspaceUUID, userUUID, resourceUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendUserWithBody(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendUserRequestWithBody(c.Server, workspaceUUID, userUUID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendUser(ctx context.Context, workspaceUUID string, userUUID string, body SuspendUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendUserRequest(c.Server, workspaceUUID, userUUID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenIdTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIdTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenIdToken(ctx context.Context, body GetOpenIdTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIdTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAcceptInvitationRequest calls the generic AcceptInvitation builder with application/json body
func NewAcceptInvitationRequest(server string, token string, body AcceptInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAcceptInvitationRequestWithBody(server, token, "application/json", bodyReader)
}

// NewAcceptInvitationRequestWithBody generates requests for AcceptInvitation with any type of body
func NewAcceptInvitationRequestWithBody(server string, token string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/accept-invitation/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAuthTokenWithCredRequest calls the generic CreateAuthTokenWithCred builder with application/json body
func NewCreateAuthTokenWithCredRequest(server string, body CreateAuthTokenWithCredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthTokenWithCredRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuthTokenWithCredRequestWithBody generates requests for CreateAuthTokenWithCred with any type of body
func NewCreateAuthTokenWithCredRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/authn/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAuthTokenWithChallengeRequest calls the generic CreateAuthTokenWithChallenge builder with application/json body
func NewCreateAuthTokenWithChallengeRequest(server string, body CreateAuthTokenWithChallengeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuthTokenWithChallengeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuthTokenWithChallengeRequestWithBody generates requests for CreateAuthTokenWithChallenge with any type of body
func NewCreateAuthTokenWithChallengeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/authn/challenge/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDetailedGroupsRequest generates requests for ListDetailedGroups
func NewListDetailedGroupsRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/group/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDetailedGroupRequest generates requests for GetDetailedGroup
func NewGetDetailedGroupRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/group/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDetailedServiceUsersRequest generates requests for ListDetailedServiceUsers
func NewListDetailedServiceUsersRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/service-user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDetailedServiceUserRequest generates requests for GetDetailedServiceUser
func NewGetDetailedServiceUserRequest(server string, workspaceUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/service-user/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDetailedWorkspaceUsersRequest generates requests for ListDetailedWorkspaceUsers
func NewListDetailedWorkspaceUsersRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDetailedWorkspaceUserRequest generates requests for GetDetailedWorkspaceUser
func NewGetDetailedWorkspaceUserRequest(server string, workspaceUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/detailed/workspace/%s/user/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIamV1ApiV1HealthzRequest generates requests for GetIamV1ApiV1Healthz
func NewGetIamV1ApiV1HealthzRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/healthz/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThirdPartyAccessTokenRequest calls the generic GetThirdPartyAccessToken builder with application/json body
func NewGetThirdPartyAccessTokenRequest(server string, organizationUUID string, thirdPartyUUID string, body GetThirdPartyAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetThirdPartyAccessTokenRequestWithBody(server, organizationUUID, thirdPartyUUID, "application/json", bodyReader)
}

// NewGetThirdPartyAccessTokenRequestWithBody generates requests for GetThirdPartyAccessToken with any type of body
func NewGetThirdPartyAccessTokenRequestWithBody(server string, organizationUUID string, thirdPartyUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organizationUUID", runtime.ParamLocationPath, organizationUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "thirdPartyUUID", runtime.ParamLocationPath, thirdPartyUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/organizations/%s/third-parties/%s/access-tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChangePasswordRequest calls the generic ChangePassword builder with application/json body
func NewChangePasswordRequest(server string, token string, body ChangePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePasswordRequestWithBody(server, token, "application/json", bodyReader)
}

// NewChangePasswordRequestWithBody generates requests for ChangePassword with any type of body
func NewChangePasswordRequestWithBody(server string, token string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/change-password/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/reset-password/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkCanUserRequest calls the generic BulkCanUser builder with application/json body
func NewBulkCanUserRequest(server string, userUUID string, workspaceUUID string, body BulkCanUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCanUserRequestWithBody(server, userUUID, workspaceUUID, "application/json", bodyReader)
}

// NewBulkCanUserRequestWithBody generates requests for BulkCanUser with any type of body
func NewBulkCanUserRequestWithBody(server string, userUUID string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/bulk-can/workspace/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableUserOtpRequest generates requests for DisableUserOtp
func NewDisableUserOtpRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/otp/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserOtpStatusRequest generates requests for GetUserOtpStatus
func NewGetUserOtpStatusRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/otp/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableUserOtpRequest calls the generic EnableUserOtp builder with application/json body
func NewEnableUserOtpRequest(server string, userUUID string, body EnableUserOtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableUserOtpRequestWithBody(server, userUUID, "application/json", bodyReader)
}

// NewEnableUserOtpRequestWithBody generates requests for EnableUserOtp with any type of body
func NewEnableUserOtpRequestWithBody(server string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/otp/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserPublicKeysRequest generates requests for ListUserPublicKeys
func NewListUserPublicKeysRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/public-key/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserPublicKeyRequest calls the generic CreateUserPublicKey builder with application/json body
func NewCreateUserPublicKeyRequest(server string, userUUID string, body CreateUserPublicKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserPublicKeyRequestWithBody(server, userUUID, "application/json", bodyReader)
}

// NewCreateUserPublicKeyRequestWithBody generates requests for CreateUserPublicKey with any type of body
func NewCreateUserPublicKeyRequestWithBody(server string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/public-key/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserPublicKeyRequest generates requests for DeleteUserPublicKey
func NewDeleteUserPublicKeyRequest(server string, userUUID string, resourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceId", runtime.ParamLocationPath, resourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/public-key/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserTokensRequest generates requests for ListUserTokens
func NewListUserTokensRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/user-token/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserTokenRequest calls the generic CreateUserToken builder with application/json body
func NewCreateUserTokenRequest(server string, userUUID string, body CreateUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserTokenRequestWithBody(server, userUUID, "application/json", bodyReader)
}

// NewCreateUserTokenRequestWithBody generates requests for CreateUserToken with any type of body
func NewCreateUserTokenRequestWithBody(server string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/user-token/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserTokenRequest generates requests for DeleteUserToken
func NewDeleteUserTokenRequest(server string, userUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/user-token/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserWorkspacesRequest generates requests for ListUserWorkspaces
func NewListUserWorkspacesRequest(server string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/user/%s/workspace/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBackupKeysRequest generates requests for ListBackupKeys
func NewListBackupKeysRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/backup-key/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackupKeyRequest calls the generic CreateBackupKey builder with application/json body
func NewCreateBackupKeyRequest(server string, workspaceUUID string, body CreateBackupKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackupKeyRequestWithBody(server, workspaceUUID, "application/json", bodyReader)
}

// NewCreateBackupKeyRequestWithBody generates requests for CreateBackupKey with any type of body
func NewCreateBackupKeyRequestWithBody(server string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/backup-key/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackupKeyRequest generates requests for DeleteBackupKey
func NewDeleteBackupKeyRequest(server string, workspaceUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/backup-key/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, workspaceUUID string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, workspaceUUID, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, workspaceUUID string, groupUUID string, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, workspaceUUID, groupUUID, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, workspaceUUID string, groupUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkAddRolesToGroupRequest generates requests for BulkAddRolesToGroup
func NewBulkAddRolesToGroupRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/bulk-add-roles/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkAddServiceUsersToGroupRequest calls the generic BulkAddServiceUsersToGroup builder with application/json body
func NewBulkAddServiceUsersToGroupRequest(server string, workspaceUUID string, groupUUID string, body BulkAddServiceUsersToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddServiceUsersToGroupRequestWithBody(server, workspaceUUID, groupUUID, "application/json", bodyReader)
}

// NewBulkAddServiceUsersToGroupRequestWithBody generates requests for BulkAddServiceUsersToGroup with any type of body
func NewBulkAddServiceUsersToGroupRequestWithBody(server string, workspaceUUID string, groupUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/bulk-add-service-users/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkAddUsersToGroupRequest calls the generic BulkAddUsersToGroup builder with application/json body
func NewBulkAddUsersToGroupRequest(server string, workspaceUUID string, groupUUID string, body BulkAddUsersToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddUsersToGroupRequestWithBody(server, workspaceUUID, groupUUID, "application/json", bodyReader)
}

// NewBulkAddUsersToGroupRequestWithBody generates requests for BulkAddUsersToGroup with any type of body
func NewBulkAddUsersToGroupRequestWithBody(server string, workspaceUUID string, groupUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/bulk-add-users/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupRolesRequest generates requests for ListGroupRoles
func NewListGroupRolesRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/role/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupServiceUsersRequest generates requests for ListGroupServiceUsers
func NewListGroupServiceUsersRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/service-user/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveServiceUserFromGroupRequest generates requests for RemoveServiceUserFromGroup
func NewRemoveServiceUserFromGroupRequest(server string, workspaceUUID string, groupUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/service-user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddServiceUserToGroupRequest calls the generic AddServiceUserToGroup builder with application/json body
func NewAddServiceUserToGroupRequest(server string, workspaceUUID string, groupUUID string, serviceUserUUID string, body AddServiceUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddServiceUserToGroupRequestWithBody(server, workspaceUUID, groupUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewAddServiceUserToGroupRequestWithBody generates requests for AddServiceUserToGroup with any type of body
func NewAddServiceUserToGroupRequestWithBody(server string, workspaceUUID string, groupUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/service-user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupUsersRequest generates requests for ListGroupUsers
func NewListGroupUsersRequest(server string, workspaceUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/user/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserFromGroupRequest generates requests for RemoveUserFromGroup
func NewRemoveUserFromGroupRequest(server string, workspaceUUID string, groupUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToGroupRequest calls the generic AddUserToGroup builder with application/json body
func NewAddUserToGroupRequest(server string, workspaceUUID string, groupUUID string, userUUID string, body AddUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToGroupRequestWithBody(server, workspaceUUID, groupUUID, userUUID, "application/json", bodyReader)
}

// NewAddUserToGroupRequestWithBody generates requests for AddUserToGroup with any type of body
func NewAddUserToGroupRequestWithBody(server string, workspaceUUID string, groupUUID string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/group/%s/user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInviteUsersToWorkspaceRequest calls the generic InviteUsersToWorkspace builder with application/json body
func NewInviteUsersToWorkspaceRequest(server string, workspaceUUID string, body InviteUsersToWorkspaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInviteUsersToWorkspaceRequestWithBody(server, workspaceUUID, "application/json", bodyReader)
}

// NewInviteUsersToWorkspaceRequestWithBody generates requests for InviteUsersToWorkspace with any type of body
func NewInviteUsersToWorkspaceRequestWithBody(server string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/invite/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceUserKiseKeysRequest generates requests for ListServiceUserKiseKeys
func NewListServiceUserKiseKeysRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/kise/key/service-user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRolesRequest generates requests for ListRoles
func NewListRolesRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest generates requests for CreateRole
func NewCreateRoleRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, workspaceUUID string, roleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, workspaceUUID string, roleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkAddRulesToRoleRequest calls the generic BulkAddRulesToRole builder with application/json body
func NewBulkAddRulesToRoleRequest(server string, workspaceUUID string, roleUUID string, body BulkAddRulesToRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddRulesToRoleRequestWithBody(server, workspaceUUID, roleUUID, "application/json", bodyReader)
}

// NewBulkAddRulesToRoleRequestWithBody generates requests for BulkAddRulesToRole with any type of body
func NewBulkAddRulesToRoleRequestWithBody(server string, workspaceUUID string, roleUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/bulk-add-rules/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkAddServiceUsersToRoleRequest calls the generic BulkAddServiceUsersToRole builder with application/json body
func NewBulkAddServiceUsersToRoleRequest(server string, workspaceUUID string, roleUUID string, body BulkAddServiceUsersToRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddServiceUsersToRoleRequestWithBody(server, workspaceUUID, roleUUID, "application/json", bodyReader)
}

// NewBulkAddServiceUsersToRoleRequestWithBody generates requests for BulkAddServiceUsersToRole with any type of body
func NewBulkAddServiceUsersToRoleRequestWithBody(server string, workspaceUUID string, roleUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/bulk-add-service-users/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkAddUsersToRoleRequest calls the generic BulkAddUsersToRole builder with application/json body
func NewBulkAddUsersToRoleRequest(server string, workspaceUUID string, roleUUID string, body BulkAddUsersToRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddUsersToRoleRequestWithBody(server, workspaceUUID, roleUUID, "application/json", bodyReader)
}

// NewBulkAddUsersToRoleRequestWithBody generates requests for BulkAddUsersToRole with any type of body
func NewBulkAddUsersToRoleRequestWithBody(server string, workspaceUUID string, roleUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/bulk-add-users/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRoleFromGroupRequest generates requests for RemoveRoleFromGroup
func NewRemoveRoleFromGroupRequest(server string, workspaceUUID string, roleUUID string, groupUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "groupUUID", runtime.ParamLocationPath, groupUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/group/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRoleRulesRequest generates requests for ListRoleRules
func NewListRoleRulesRequest(server string, workspaceUUID string, roleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/rule/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRuleFromRoleRequest generates requests for RemoveRuleFromRole
func NewRemoveRuleFromRoleRequest(server string, workspaceUUID string, roleUUID string, ruleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/rule/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRuleToRoleRequest calls the generic AddRuleToRole builder with application/json body
func NewAddRuleToRoleRequest(server string, workspaceUUID string, roleUUID string, ruleUUID string, body AddRuleToRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRuleToRoleRequestWithBody(server, workspaceUUID, roleUUID, ruleUUID, "application/json", bodyReader)
}

// NewAddRuleToRoleRequestWithBody generates requests for AddRuleToRole with any type of body
func NewAddRuleToRoleRequestWithBody(server string, workspaceUUID string, roleUUID string, ruleUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/rule/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceUsersRoleBindingsRequest generates requests for ListServiceUsersRoleBindings
func NewListServiceUsersRoleBindingsRequest(server string, workspaceUUID string, roleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/service-user/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRoleFromServiceUserRequest generates requests for RemoveRoleFromServiceUser
func NewRemoveRoleFromServiceUserRequest(server string, workspaceUUID string, roleUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/service-user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceUserRoleBindingRequest generates requests for GetServiceUserRoleBinding
func NewGetServiceUserRoleBindingRequest(server string, workspaceUUID string, roleUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/service-user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToServiceUserRequest calls the generic AssignRoleToServiceUser builder with application/json body
func NewAssignRoleToServiceUserRequest(server string, workspaceUUID string, roleUUID string, serviceUserUUID string, body AssignRoleToServiceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignRoleToServiceUserRequestWithBody(server, workspaceUUID, roleUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewAssignRoleToServiceUserRequestWithBody generates requests for AssignRoleToServiceUser with any type of body
func NewAssignRoleToServiceUserRequestWithBody(server string, workspaceUUID string, roleUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/service-user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRoleBindingsRequest generates requests for ListUsersRoleBindings
func NewListUsersRoleBindingsRequest(server string, workspaceUUID string, roleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/user/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveRoleFromUserRequest generates requests for RemoveRoleFromUser
func NewRemoveRoleFromUserRequest(server string, workspaceUUID string, roleUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRoleBindingRequest generates requests for GetUserRoleBinding
func NewGetUserRoleBindingRequest(server string, workspaceUUID string, roleUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignRoleToUserRequest calls the generic AssignRoleToUser builder with application/json body
func NewAssignRoleToUserRequest(server string, workspaceUUID string, roleUUID string, userUUID string, body AssignRoleToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssignRoleToUserRequestWithBody(server, workspaceUUID, roleUUID, userUUID, "application/json", bodyReader)
}

// NewAssignRoleToUserRequestWithBody generates requests for AssignRoleToUser with any type of body
func NewAssignRoleToUserRequestWithBody(server string, workspaceUUID string, roleUUID string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "roleUUID", runtime.ParamLocationPath, roleUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/role/%s/user/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRulesRequest generates requests for ListRules
func NewListRulesRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, workspaceUUID string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, workspaceUUID, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, workspaceUUID string, ruleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleRequest generates requests for GetRule
func NewGetRuleRequest(server string, workspaceUUID string, ruleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, workspaceUUID string, ruleUUID string, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, workspaceUUID, ruleUUID, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, workspaceUUID string, ruleUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRuleRolesRequest generates requests for ListRuleRoles
func NewListRuleRolesRequest(server string, workspaceUUID string, ruleUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ruleUUID", runtime.ParamLocationPath, ruleUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/rule/%s/role/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceUsersRequest generates requests for ListServiceUsers
func NewListServiceUsersRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceUserRequest calls the generic CreateServiceUser builder with application/json body
func NewCreateServiceUserRequest(server string, workspaceUUID string, body CreateServiceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceUserRequestWithBody(server, workspaceUUID, "application/json", bodyReader)
}

// NewCreateServiceUserRequestWithBody generates requests for CreateServiceUser with any type of body
func NewCreateServiceUserRequestWithBody(server string, workspaceUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceUserRequest generates requests for DeleteServiceUser
func NewDeleteServiceUserRequest(server string, workspaceUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceUserRequest calls the generic UpdateServiceUser builder with application/json body
func NewUpdateServiceUserRequest(server string, workspaceUUID string, serviceUserUUID string, body UpdateServiceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceUserRequestWithBody(server, workspaceUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewUpdateServiceUserRequestWithBody generates requests for UpdateServiceUser with any type of body
func NewUpdateServiceUserRequestWithBody(server string, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateServiceUserKiseKeyRequest calls the generic CreateServiceUserKiseKey builder with application/json body
func NewCreateServiceUserKiseKeyRequest(server string, workspaceUUID string, serviceUserUUID string, body CreateServiceUserKiseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceUserKiseKeyRequestWithBody(server, workspaceUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewCreateServiceUserKiseKeyRequestWithBody generates requests for CreateServiceUserKiseKey with any type of body
func NewCreateServiceUserKiseKeyRequestWithBody(server string, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/kise/key/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceUserKiseKeyRequest generates requests for DeleteServiceUserKiseKey
func NewDeleteServiceUserKiseKeyRequest(server string, workspaceUUID string, serviceUserUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/kise/key/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceUserPublicKeysRequest generates requests for ListServiceUserPublicKeys
func NewListServiceUserPublicKeysRequest(server string, workspaceUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/service-user-public-key/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceUserPublicKeyRequest calls the generic CreateServiceUserPublicKey builder with application/json body
func NewCreateServiceUserPublicKeyRequest(server string, workspaceUUID string, serviceUserUUID string, body CreateServiceUserPublicKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceUserPublicKeyRequestWithBody(server, workspaceUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewCreateServiceUserPublicKeyRequestWithBody generates requests for CreateServiceUserPublicKey with any type of body
func NewCreateServiceUserPublicKeyRequestWithBody(server string, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/service-user-public-key/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceUserPublicKeyRequest generates requests for DeleteServiceUserPublicKey
func NewDeleteServiceUserPublicKeyRequest(server string, workspaceUUID string, serviceUserUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/service-user-public-key/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServiceUserTokensRequest generates requests for ListServiceUserTokens
func NewListServiceUserTokensRequest(server string, workspaceUUID string, serviceUserUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/token/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceUserTokenRequest calls the generic CreateServiceUserToken builder with application/json body
func NewCreateServiceUserTokenRequest(server string, workspaceUUID string, serviceUserUUID string, body CreateServiceUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceUserTokenRequestWithBody(server, workspaceUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewCreateServiceUserTokenRequestWithBody generates requests for CreateServiceUserToken with any type of body
func NewCreateServiceUserTokenRequestWithBody(server string, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/token/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceUserTokenRequest generates requests for DeleteServiceUserToken
func NewDeleteServiceUserTokenRequest(server string, workspaceUUID string, serviceUserUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service-user/%s/token/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListServicesRequest generates requests for ListServices
func NewListServicesRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/service/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkRefreshThirdPartyTokensRequest calls the generic BulkRefreshThirdPartyTokens builder with application/json body
func NewBulkRefreshThirdPartyTokensRequest(server string, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, body BulkRefreshThirdPartyTokensJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkRefreshThirdPartyTokensRequestWithBody(server, workspaceUUID, thirdPartyUUID, serviceUserUUID, "application/json", bodyReader)
}

// NewBulkRefreshThirdPartyTokensRequestWithBody generates requests for BulkRefreshThirdPartyTokens with any type of body
func NewBulkRefreshThirdPartyTokensRequestWithBody(server string, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "thirdPartyUUID", runtime.ParamLocationPath, thirdPartyUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "serviceUserUUID", runtime.ParamLocationPath, serviceUserUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/third-parties/%s/service-users/%s/bulk-refresh-tokens", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkspaceUsersRequest generates requests for ListWorkspaceUsers
func NewListWorkspaceUsersRequest(server string, workspaceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveUserFromWorkspaceRequest generates requests for RemoveUserFromWorkspace
func NewRemoveUserFromWorkspaceRequest(server string, workspaceUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllowUserRequest calls the generic AllowUser builder with application/json body
func NewAllowUserRequest(server string, workspaceUUID string, userUUID string, body AllowUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAllowUserRequestWithBody(server, workspaceUUID, userUUID, "application/json", bodyReader)
}

// NewAllowUserRequestWithBody generates requests for AllowUser with any type of body
func NewAllowUserRequestWithBody(server string, workspaceUUID string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/allow/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserKiseKeysRequest generates requests for ListUserKiseKeys
func NewListUserKiseKeysRequest(server string, workspaceUUID string, userUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/kise/key/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserKiseKeyRequest calls the generic CreateUserKiseKey builder with application/json body
func NewCreateUserKiseKeyRequest(server string, workspaceUUID string, userUUID string, body CreateUserKiseKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserKiseKeyRequestWithBody(server, workspaceUUID, userUUID, "application/json", bodyReader)
}

// NewCreateUserKiseKeyRequestWithBody generates requests for CreateUserKiseKey with any type of body
func NewCreateUserKiseKeyRequestWithBody(server string, workspaceUUID string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/kise/key/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserKiseKeyRequest generates requests for DeleteUserKiseKey
func NewDeleteUserKiseKeyRequest(server string, workspaceUUID string, userUUID string, resourceUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourceUUID", runtime.ParamLocationPath, resourceUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/kise/key/%s/", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuspendUserRequest calls the generic SuspendUser builder with application/json body
func NewSuspendUserRequest(server string, workspaceUUID string, userUUID string, body SuspendUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSuspendUserRequestWithBody(server, workspaceUUID, userUUID, "application/json", bodyReader)
}

// NewSuspendUserRequestWithBody generates requests for SuspendUser with any type of body
func NewSuspendUserRequestWithBody(server string, workspaceUUID string, userUUID string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workspaceUUID", runtime.ParamLocationPath, workspaceUUID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userUUID", runtime.ParamLocationPath, userUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/api/v1/workspace/%s/user/%s/suspend/", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOpenIdTokenRequest calls the generic GetOpenIdToken builder with application/json body
func NewGetOpenIdTokenRequest(server string, body GetOpenIdTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetOpenIdTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewGetOpenIdTokenRequestWithBody generates requests for GetOpenIdToken with any type of body
func NewGetOpenIdTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iam/v1/openid/token/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AcceptInvitationWithBodyWithResponse request with any body
	AcceptInvitationWithBodyWithResponse(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error)

	AcceptInvitationWithResponse(ctx context.Context, token string, body AcceptInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error)

	// CreateAuthTokenWithCredWithBodyWithResponse request with any body
	CreateAuthTokenWithCredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithCredResponse, error)

	CreateAuthTokenWithCredWithResponse(ctx context.Context, body CreateAuthTokenWithCredJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithCredResponse, error)

	// CreateAuthTokenWithChallengeWithBodyWithResponse request with any body
	CreateAuthTokenWithChallengeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithChallengeResponse, error)

	CreateAuthTokenWithChallengeWithResponse(ctx context.Context, body CreateAuthTokenWithChallengeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithChallengeResponse, error)

	// ListDetailedGroupsWithResponse request
	ListDetailedGroupsWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedGroupsResponse, error)

	// GetDetailedGroupWithResponse request
	GetDetailedGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*GetDetailedGroupResponse, error)

	// ListDetailedServiceUsersWithResponse request
	ListDetailedServiceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedServiceUsersResponse, error)

	// GetDetailedServiceUserWithResponse request
	GetDetailedServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*GetDetailedServiceUserResponse, error)

	// ListDetailedWorkspaceUsersWithResponse request
	ListDetailedWorkspaceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedWorkspaceUsersResponse, error)

	// GetDetailedWorkspaceUserWithResponse request
	GetDetailedWorkspaceUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*GetDetailedWorkspaceUserResponse, error)

	// GetIamV1ApiV1HealthzWithResponse request
	GetIamV1ApiV1HealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIamV1ApiV1HealthzResponse, error)

	// GetThirdPartyAccessTokenWithBodyWithResponse request with any body
	GetThirdPartyAccessTokenWithBodyWithResponse(ctx context.Context, organizationUUID string, thirdPartyUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetThirdPartyAccessTokenResponse, error)

	GetThirdPartyAccessTokenWithResponse(ctx context.Context, organizationUUID string, thirdPartyUUID string, body GetThirdPartyAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetThirdPartyAccessTokenResponse, error)

	// ChangePasswordWithBodyWithResponse request with any body
	ChangePasswordWithBodyWithResponse(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	ChangePasswordWithResponse(ctx context.Context, token string, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// BulkCanUserWithBodyWithResponse request with any body
	BulkCanUserWithBodyWithResponse(ctx context.Context, userUUID string, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCanUserResponse, error)

	BulkCanUserWithResponse(ctx context.Context, userUUID string, workspaceUUID string, body BulkCanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCanUserResponse, error)

	// DisableUserOtpWithResponse request
	DisableUserOtpWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*DisableUserOtpResponse, error)

	// GetUserOtpStatusWithResponse request
	GetUserOtpStatusWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*GetUserOtpStatusResponse, error)

	// EnableUserOtpWithBodyWithResponse request with any body
	EnableUserOtpWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableUserOtpResponse, error)

	EnableUserOtpWithResponse(ctx context.Context, userUUID string, body EnableUserOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableUserOtpResponse, error)

	// ListUserPublicKeysWithResponse request
	ListUserPublicKeysWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserPublicKeysResponse, error)

	// CreateUserPublicKeyWithBodyWithResponse request with any body
	CreateUserPublicKeyWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserPublicKeyResponse, error)

	CreateUserPublicKeyWithResponse(ctx context.Context, userUUID string, body CreateUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserPublicKeyResponse, error)

	// DeleteUserPublicKeyWithResponse request
	DeleteUserPublicKeyWithResponse(ctx context.Context, userUUID string, resourceId string, reqEditors ...RequestEditorFn) (*DeleteUserPublicKeyResponse, error)

	// ListUserTokensWithResponse request
	ListUserTokensWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserTokensResponse, error)

	// CreateUserTokenWithBodyWithResponse request with any body
	CreateUserTokenWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error)

	CreateUserTokenWithResponse(ctx context.Context, userUUID string, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error)

	// DeleteUserTokenWithResponse request
	DeleteUserTokenWithResponse(ctx context.Context, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error)

	// ListUserWorkspacesWithResponse request
	ListUserWorkspacesWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error)

	// ListBackupKeysWithResponse request
	ListBackupKeysWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListBackupKeysResponse, error)

	// CreateBackupKeyWithBodyWithResponse request with any body
	CreateBackupKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupKeyResponse, error)

	CreateBackupKeyWithResponse(ctx context.Context, workspaceUUID string, body CreateBackupKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupKeyResponse, error)

	// DeleteBackupKeyWithResponse request
	DeleteBackupKeyWithResponse(ctx context.Context, workspaceUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteBackupKeyResponse, error)

	// ListGroupsWithResponse request
	ListGroupsWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, workspaceUUID string, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// BulkAddRolesToGroupWithResponse request
	BulkAddRolesToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*BulkAddRolesToGroupResponse, error)

	// BulkAddServiceUsersToGroupWithBodyWithResponse request with any body
	BulkAddServiceUsersToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToGroupResponse, error)

	BulkAddServiceUsersToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddServiceUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToGroupResponse, error)

	// BulkAddUsersToGroupWithBodyWithResponse request with any body
	BulkAddUsersToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddUsersToGroupResponse, error)

	BulkAddUsersToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddUsersToGroupResponse, error)

	// ListGroupRolesWithResponse request
	ListGroupRolesWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupRolesResponse, error)

	// ListGroupServiceUsersWithResponse request
	ListGroupServiceUsersWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupServiceUsersResponse, error)

	// RemoveServiceUserFromGroupWithResponse request
	RemoveServiceUserFromGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*RemoveServiceUserFromGroupResponse, error)

	// AddServiceUserToGroupWithBodyWithResponse request with any body
	AddServiceUserToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddServiceUserToGroupResponse, error)

	AddServiceUserToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, body AddServiceUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddServiceUserToGroupResponse, error)

	// ListGroupUsersWithResponse request
	ListGroupUsersWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error)

	// RemoveUserFromGroupWithResponse request
	RemoveUserFromGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error)

	// AddUserToGroupWithBodyWithResponse request with any body
	AddUserToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	AddUserToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error)

	// InviteUsersToWorkspaceWithBodyWithResponse request with any body
	InviteUsersToWorkspaceWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersToWorkspaceResponse, error)

	InviteUsersToWorkspaceWithResponse(ctx context.Context, workspaceUUID string, body InviteUsersToWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersToWorkspaceResponse, error)

	// ListServiceUserKiseKeysWithResponse request
	ListServiceUserKiseKeysWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserKiseKeysResponse, error)

	// ListRolesWithResponse request
	ListRolesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListRolesResponse, error)

	// CreateRoleWithResponse request
	CreateRoleWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// BulkAddRulesToRoleWithBodyWithResponse request with any body
	BulkAddRulesToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddRulesToRoleResponse, error)

	BulkAddRulesToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddRulesToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddRulesToRoleResponse, error)

	// BulkAddServiceUsersToRoleWithBodyWithResponse request with any body
	BulkAddServiceUsersToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToRoleResponse, error)

	BulkAddServiceUsersToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddServiceUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToRoleResponse, error)

	// BulkAddUsersToRoleWithBodyWithResponse request with any body
	BulkAddUsersToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddUsersToRoleResponse, error)

	BulkAddUsersToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddUsersToRoleResponse, error)

	// RemoveRoleFromGroupWithResponse request
	RemoveRoleFromGroupWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromGroupResponse, error)

	// ListRoleRulesWithResponse request
	ListRoleRulesWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListRoleRulesResponse, error)

	// RemoveRuleFromRoleWithResponse request
	RemoveRuleFromRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*RemoveRuleFromRoleResponse, error)

	// AddRuleToRoleWithBodyWithResponse request with any body
	AddRuleToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuleToRoleResponse, error)

	AddRuleToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, body AddRuleToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuleToRoleResponse, error)

	// ListServiceUsersRoleBindingsWithResponse request
	ListServiceUsersRoleBindingsWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListServiceUsersRoleBindingsResponse, error)

	// RemoveRoleFromServiceUserWithResponse request
	RemoveRoleFromServiceUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromServiceUserResponse, error)

	// GetServiceUserRoleBindingWithResponse request
	GetServiceUserRoleBindingWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*GetServiceUserRoleBindingResponse, error)

	// AssignRoleToServiceUserWithBodyWithResponse request with any body
	AssignRoleToServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToServiceUserResponse, error)

	AssignRoleToServiceUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, body AssignRoleToServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToServiceUserResponse, error)

	// ListUsersRoleBindingsWithResponse request
	ListUsersRoleBindingsWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListUsersRoleBindingsResponse, error)

	// RemoveRoleFromUserWithResponse request
	RemoveRoleFromUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromUserResponse, error)

	// GetUserRoleBindingWithResponse request
	GetUserRoleBindingWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*GetUserRoleBindingResponse, error)

	// AssignRoleToUserWithBodyWithResponse request with any body
	AssignRoleToUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error)

	AssignRoleToUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error)

	// ListRulesWithResponse request
	ListRulesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListRulesResponse, error)

	// CreateRuleWithBodyWithResponse request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, workspaceUUID string, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleWithResponse request
	GetRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*GetRuleResponse, error)

	// UpdateRuleWithBodyWithResponse request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// ListRuleRolesWithResponse request
	ListRuleRolesWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*ListRuleRolesResponse, error)

	// ListServiceUsersWithResponse request
	ListServiceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServiceUsersResponse, error)

	// CreateServiceUserWithBodyWithResponse request with any body
	CreateServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserResponse, error)

	CreateServiceUserWithResponse(ctx context.Context, workspaceUUID string, body CreateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserResponse, error)

	// DeleteServiceUserWithResponse request
	DeleteServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserResponse, error)

	// UpdateServiceUserWithBodyWithResponse request with any body
	UpdateServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceUserResponse, error)

	UpdateServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body UpdateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceUserResponse, error)

	// CreateServiceUserKiseKeyWithBodyWithResponse request with any body
	CreateServiceUserKiseKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserKiseKeyResponse, error)

	CreateServiceUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserKiseKeyResponse, error)

	// DeleteServiceUserKiseKeyWithResponse request
	DeleteServiceUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserKiseKeyResponse, error)

	// ListServiceUserPublicKeysWithResponse request
	ListServiceUserPublicKeysWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserPublicKeysResponse, error)

	// CreateServiceUserPublicKeyWithBodyWithResponse request with any body
	CreateServiceUserPublicKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserPublicKeyResponse, error)

	CreateServiceUserPublicKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserPublicKeyResponse, error)

	// DeleteServiceUserPublicKeyWithResponse request
	DeleteServiceUserPublicKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserPublicKeyResponse, error)

	// ListServiceUserTokensWithResponse request
	ListServiceUserTokensWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserTokensResponse, error)

	// CreateServiceUserTokenWithBodyWithResponse request with any body
	CreateServiceUserTokenWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserTokenResponse, error)

	CreateServiceUserTokenWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserTokenResponse, error)

	// DeleteServiceUserTokenWithResponse request
	DeleteServiceUserTokenWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserTokenResponse, error)

	// ListServicesWithResponse request
	ListServicesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServicesResponse, error)

	// BulkRefreshThirdPartyTokensWithBodyWithResponse request with any body
	BulkRefreshThirdPartyTokensWithBodyWithResponse(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkRefreshThirdPartyTokensResponse, error)

	BulkRefreshThirdPartyTokensWithResponse(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, body BulkRefreshThirdPartyTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkRefreshThirdPartyTokensResponse, error)

	// ListWorkspaceUsersWithResponse request
	ListWorkspaceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error)

	// RemoveUserFromWorkspaceWithResponse request
	RemoveUserFromWorkspaceWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveUserFromWorkspaceResponse, error)

	// AllowUserWithBodyWithResponse request with any body
	AllowUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AllowUserResponse, error)

	AllowUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body AllowUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AllowUserResponse, error)

	// ListUserKiseKeysWithResponse request
	ListUserKiseKeysWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*ListUserKiseKeysResponse, error)

	// CreateUserKiseKeyWithBodyWithResponse request with any body
	CreateUserKiseKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserKiseKeyResponse, error)

	CreateUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body CreateUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserKiseKeyResponse, error)

	// DeleteUserKiseKeyWithResponse request
	DeleteUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteUserKiseKeyResponse, error)

	// SuspendUserWithBodyWithResponse request with any body
	SuspendUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendUserResponse, error)

	SuspendUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body SuspendUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendUserResponse, error)

	// GetOpenIdTokenWithBodyWithResponse request with any body
	GetOpenIdTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOpenIdTokenResponse, error)

	GetOpenIdTokenWithResponse(ctx context.Context, body GetOpenIdTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOpenIdTokenResponse, error)
}

type AcceptInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON404 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AcceptInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthTokenWithCredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ChallengeToken Token to be used when responding to the challenge
		ChallengeToken string `json:"challenge_token"`

		// ChallengeType Type of challenge (e.g., 'otp', 'sms')
		ChallengeType string `json:"challenge_type"`

		// Message Human-readable message about the challenge
		Message string `json:"message"`
	}
	JSON201 *struct {
		// ExpiresAt Token expiration timestamp
		ExpiresAt time.Time `json:"expires_at"`

		// Token Authentication token
		Token string `json:"token"`

		// UserUuid UUID of the authenticated user
		UserUuid string `json:"user_uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON404 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAuthTokenWithCredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthTokenWithCredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthTokenWithChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ChallengeToken Token to be used when responding to the challenge
		ChallengeToken string `json:"challenge_token"`

		// ChallengeType Type of challenge (e.g., 'otp', 'sms')
		ChallengeType string `json:"challenge_type"`

		// Message Human-readable message about the challenge
		Message string `json:"message"`
	}
	JSON201 *struct {
		// ExpiresAt Token expiration timestamp
		ExpiresAt time.Time `json:"expires_at"`

		// Token Authentication token
		Token string `json:"token"`

		// UserUuid UUID of the authenticated user
		UserUuid string `json:"user_uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAuthTokenWithChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthTokenWithChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDetailedGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// Roles List of roles assigned to the group
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// ServiceUsers List of service user members in the group
		ServiceUsers []struct {
			// CreatedAt Timestamp when the member was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the member
			Email string `json:"email"`

			// Name Name of the member
			Name string `json:"name"`

			// Uuid Unique identifier for the member
			Uuid string `json:"uuid"`
		} `json:"service_users"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Users List of user members in the group
		Users []struct {
			// CreatedAt Timestamp when the member was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the member
			Email string `json:"email"`

			// Name Name of the member
			Name string `json:"name"`

			// Uuid Unique identifier for the member
			Uuid string `json:"uuid"`
		} `json:"users"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDetailedGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDetailedGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDetailedGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// Roles List of roles assigned to the group
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// ServiceUsers List of service user members in the group
		ServiceUsers []struct {
			// CreatedAt Timestamp when the member was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the member
			Email string `json:"email"`

			// Name Name of the member
			Name string `json:"name"`

			// Uuid Unique identifier for the member
			Uuid string `json:"uuid"`
		} `json:"service_users"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Users List of user members in the group
		Users []struct {
			// CreatedAt Timestamp when the member was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the member
			Email string `json:"email"`

			// Name Name of the member
			Name string `json:"name"`

			// Uuid Unique identifier for the member
			Uuid string `json:"uuid"`
		} `json:"users"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDetailedGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDetailedGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDetailedServiceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the service user
		Description *string `json:"description,omitempty"`

		// Groups Groups this service user belongs to
		Groups []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"groups"`

		// Name Name of the service user
		Name string `json:"name"`

		// Roles Roles assigned to this service user
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDetailedServiceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDetailedServiceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDetailedServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the service user
		Description *string `json:"description,omitempty"`

		// Groups Groups this service user belongs to
		Groups []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"groups"`

		// Name Name of the service user
		Name string `json:"name"`

		// Roles Roles assigned to this service user
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDetailedServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDetailedServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDetailedWorkspaceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the user was added to the workspace
		CreatedAt time.Time `json:"created_at"`

		// Groups Groups this user belongs to in the workspace
		Groups []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"groups"`

		// Roles Roles assigned to this user in the workspace
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// UpdatedAt Timestamp when the user's workspace information was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Workspace The workspace the user belongs to
		Workspace struct {
			// CreatedAt Timestamp when the workspace was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the workspace
			Description *string `json:"description,omitempty"`

			// Name Name of the workspace
			Name string `json:"name"`

			// UpdatedAt Timestamp when the workspace was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the workspace
			Uuid string `json:"uuid"`
		} `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDetailedWorkspaceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDetailedWorkspaceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDetailedWorkspaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the user was added to the workspace
		CreatedAt time.Time `json:"created_at"`

		// Groups Groups this user belongs to in the workspace
		Groups []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"groups"`

		// Roles Roles assigned to this user in the workspace
		Roles []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"roles"`

		// UpdatedAt Timestamp when the user's workspace information was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Workspace The workspace the user belongs to
		Workspace struct {
			// CreatedAt Timestamp when the workspace was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the workspace
			Description *string `json:"description,omitempty"`

			// Name Name of the workspace
			Name string `json:"name"`

			// UpdatedAt Timestamp when the workspace was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the workspace
			Uuid string `json:"uuid"`
		} `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDetailedWorkspaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDetailedWorkspaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIamV1ApiV1HealthzResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Caches []struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"caches"`
		Databases []struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"databases"`
		Storage struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"storage"`
	}
	JSON500 *struct {
		Caches []struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"caches"`
		Databases []struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"databases"`
		Storage struct {
			Default struct {
				Ok bool `json:"ok"`
			} `json:"default"`
		} `json:"storage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetIamV1ApiV1HealthzResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIamV1ApiV1HealthzResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThirdPartyAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken Access token for the third-party service
		AccessToken string `json:"access_token"`

		// ExpiresIn Number of seconds until the token expires
		ExpiresIn int `json:"expires_in"`

		// RefreshToken Refresh token for the third-party service
		RefreshToken *string `json:"refresh_token,omitempty"`

		// Scope Scope of access granted by the token
		Scope *string `json:"scope,omitempty"`

		// ThirdPartyUserId User ID in the third-party service
		ThirdPartyUserId *string `json:"third_party_user_id,omitempty"`

		// TokenType Type of token, typically 'Bearer'
		TokenType string `json:"token_type"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetThirdPartyAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThirdPartyAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON404 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCanUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Actions List of actions that were checked
		Actions []string `json:"actions"`

		// Allowed Whether the user is allowed to perform the actions on the specified service and path
		Allowed bool `json:"allowed"`

		// Path The path within the service that was checked
		Path string `json:"path"`

		// Service The service name that was checked
		Service string `json:"service"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkCanUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCanUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableUserOtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableUserOtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableUserOtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOtpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Enabled Whether OTP is enabled for the user
		Enabled bool `json:"enabled"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserOtpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOtpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableUserOtpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableUserOtpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableUserOtpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the public key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The public key content in SSH format
		Key string `json:"key"`

		// Title Title or name for the public key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the public key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user this public key belongs to
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the public key
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserPublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the public key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The public key content in SSH format
		Key string `json:"key"`

		// Title Title or name for the public key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the public key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user this public key belongs to
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the public key
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON409 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateUserPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ExpiresAt Token expiration timestamp
		ExpiresAt time.Time `json:"expires_at"`

		// Token Authentication token
		Token string `json:"token"`

		// UserUuid UUID of the authenticated user
		UserUuid string `json:"user_uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ExpiresAt Token expiration timestamp
		ExpiresAt time.Time `json:"expires_at"`

		// Token Authentication token
		Token string `json:"token"`

		// UserUuid UUID of the authenticated user
		UserUuid string `json:"user_uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserWorkspacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserWorkspacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserWorkspacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBackupKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the backup key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The SSH key content in SSH format
		Key string `json:"key"`

		// Title Title or name for the backup key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the backup key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the backup key
		Uuid string `json:"uuid"`

		// Workspace The workspace this backup key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBackupKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBackupKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the backup key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The SSH key content in SSH format
		Key string `json:"key"`

		// Title Title or name for the backup key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the backup key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the backup key
		Uuid string `json:"uuid"`

		// Workspace The workspace this backup key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON409 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBackupKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteBackupKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Optional description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Optional description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Optional description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the group was created
		CreatedAt time.Time `json:"created_at"`

		// Description Optional description of the group's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the group
		Name string `json:"name"`

		// UpdatedAt Timestamp when the group was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the group
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddRolesToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the role binding was created
		CreatedAt time.Time `json:"created_at"`

		// Group The group the role is bound to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// Role The role that is bound
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// UpdatedAt Timestamp when the role binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role binding
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddRolesToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddRolesToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddServiceUsersToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the service user was added to the group
		CreatedAt time.Time `json:"created_at"`

		// Group The group the service user was added to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// ServiceUser The service user that was added to the group
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Uuid Unique identifier for the service-user-group association
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddServiceUsersToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddServiceUsersToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddUsersToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the user was added to the group
		CreatedAt time.Time `json:"created_at"`

		// Group The group the user was added to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// User The user that was added to the group
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the user-group association
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddUsersToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddUsersToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the role was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the role's purpose and permissions
		Description *string `json:"description,omitempty"`

		// Name Name of the role
		Name string `json:"name"`

		// Service Service this role applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the role was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupServiceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Name Name of the service user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupServiceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupServiceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveServiceUserFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveServiceUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveServiceUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddServiceUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the service user was added to the group
		CreatedAt time.Time `json:"created_at"`

		// Group The group the service user was added to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// ServiceUser The service user that was added to the group
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Uuid Unique identifier for the service-user-group association
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AddServiceUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddServiceUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the user was added to the group
		CreatedAt time.Time `json:"created_at"`

		// Group The group the user was added to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// User The user that was added to the group
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the user-group association
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AddUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InviteUsersToWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created List of users that were created
		Created []struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"created"`

		// Existing List of users that already existed
		Existing []struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"existing"`

		// Invited List of email addresses that were invited
		Invited []string `json:"invited"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r InviteUsersToWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InviteUsersToWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceUserKiseKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the KISE key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The KISE key content
		Key string `json:"key"`

		// ServiceUser The service user this KISE key belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Title Title or name for the KISE key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the KISE key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the KISE key
		Uuid string `json:"uuid"`

		// Workspace The workspace this KISE key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUserKiseKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUserKiseKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the role was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the role's purpose and permissions
		Description *string `json:"description,omitempty"`

		// Name Name of the role
		Name string `json:"name"`

		// Service Service this role applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the role was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddRulesToRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the role-rule binding was created
		CreatedAt time.Time `json:"created_at"`

		// Role The role that is bound
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// Rule The rule that is bound
		Rule struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		} `json:"rule"`

		// UpdatedAt Timestamp when the role-rule binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role-rule binding
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddRulesToRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddRulesToRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddServiceUsersToRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the role binding was created
		CreatedAt time.Time `json:"created_at"`

		// Group The group the role is bound to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// Role The role that is bound
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// UpdatedAt Timestamp when the role binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role binding
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddServiceUsersToRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddServiceUsersToRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddUsersToRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]struct {
		// CreatedAt Timestamp when the role binding was created
		CreatedAt time.Time `json:"created_at"`

		// Group The group the role is bound to
		Group struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		} `json:"group"`

		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// Role The role that is bound
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// UpdatedAt Timestamp when the role binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role binding
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddUsersToRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddUsersToRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRoleFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveRoleFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRoleFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRoleRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoleRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoleRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRuleFromRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveRuleFromRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRuleFromRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRuleToRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AddRuleToRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRuleToRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceUsersRoleBindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// ServiceUser The service user
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUsersRoleBindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUsersRoleBindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRoleFromServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveRoleFromServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRoleFromServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceUserRoleBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// ServiceUser The service user
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetServiceUserRoleBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceUserRoleBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the binding was created
		CreatedAt time.Time `json:"created_at"`

		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// Role The role that was assigned to the service user
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// ServiceUser The service user that was assigned the role
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// UpdatedAt Timestamp when the binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service-user-role binding
		Uuid string `json:"uuid"`

		// Workspace The workspace in which the binding exists
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AssignRoleToServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersRoleBindingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// User The user
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsersRoleBindingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersRoleBindingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRoleFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveRoleFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRoleFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserRoleBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// User The user
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserRoleBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserRoleBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignRoleToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the binding was created
		CreatedAt time.Time `json:"created_at"`

		// Items Optional items associated with this role binding
		Items interface{} `json:"items,omitempty"`

		// Role The role that was assigned to the user
		Role struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		} `json:"role"`

		// UpdatedAt Timestamp when the binding was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user that was assigned the role
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the user-role binding
		Uuid string `json:"uuid"`

		// Workspace The workspace in which the binding exists
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AssignRoleToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignRoleToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON409 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Action Action this rule controls
		Action string `json:"action"`

		// CreatedAt Timestamp when the rule was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the rule's purpose
		Description *string `json:"description,omitempty"`

		// Name Name of the rule
		Name string `json:"name"`

		// Resource Resource this rule applies to
		Resource string `json:"resource"`

		// Service Service this rule applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the rule was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the rule
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRuleRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the role was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the role's purpose and permissions
		Description *string `json:"description,omitempty"`

		// Name Name of the role
		Name string `json:"name"`

		// Service Service this role applies to
		Service string `json:"service"`

		// UpdatedAt Timestamp when the role was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the role
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRuleRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRuleRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Name Name of the service user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Name Name of the service user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the service user was created
		CreatedAt time.Time `json:"created_at"`

		// Name Name of the service user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the service user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the service user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceUserKiseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the KISE key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The KISE key content
		Key string `json:"key"`

		// ServiceUser The service user this KISE key belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Title Title or name for the KISE key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the KISE key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the KISE key
		Uuid string `json:"uuid"`

		// Workspace The workspace this KISE key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateServiceUserKiseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceUserKiseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceUserKiseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserKiseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserKiseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceUserPublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the public key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The public key content in SSH format
		Key string `json:"key"`

		// ServiceUser The service user this public key belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Title Title or name for the public key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the public key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the public key
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUserPublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUserPublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceUserPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the public key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The public key content in SSH format
		Key string `json:"key"`

		// ServiceUser The service user this public key belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Title Title or name for the public key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the public key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the public key
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateServiceUserPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceUserPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceUserPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceUserTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the token was created
		CreatedAt time.Time `json:"created_at"`

		// ExpiresAt Timestamp when the token will expire
		ExpiresAt *time.Time `json:"expires_at,omitempty"`

		// Name Name of the token
		Name string `json:"name"`

		// ServiceUser The service user this token belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Uuid Unique identifier for the token
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUserTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUserTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the token was created
		CreatedAt time.Time `json:"created_at"`

		// ExpiresAt Timestamp when the token will expire
		ExpiresAt *time.Time `json:"expires_at,omitempty"`

		// Name Name of the token
		Name string `json:"name"`

		// Secret The secret value of the token
		Secret string `json:"secret"`

		// ServiceUser The service user this token belongs to
		ServiceUser struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		} `json:"service_user"`

		// Uuid Unique identifier for the token
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateServiceUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the service was created
		CreatedAt time.Time `json:"created_at"`

		// Description Description of the service
		Description *string `json:"description,omitempty"`

		// Name Name of the service
		Name string `json:"name"`

		// UpdatedAt Timestamp when the service was last updated
		UpdatedAt time.Time `json:"updated_at"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkRefreshThirdPartyTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// FailedTokens Map of token identifiers to error messages for tokens that failed to refresh
		FailedTokens *map[string]string `json:"failed_tokens,omitempty"`

		// RefreshedTokens Map of token identifiers to refreshed tokens
		RefreshedTokens map[string]string `json:"refreshed_tokens"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkRefreshThirdPartyTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkRefreshThirdPartyTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkspaceUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllowUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r AllowUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllowUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserKiseKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// CreatedAt Timestamp when the KISE key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The KISE key content
		Key string `json:"key"`

		// Title Title or name for the KISE key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the KISE key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user this KISE key belongs to
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the KISE key
		Uuid string `json:"uuid"`

		// Workspace The workspace this KISE key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserKiseKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserKiseKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserKiseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// CreatedAt Timestamp when the KISE key was created
		CreatedAt time.Time `json:"created_at"`

		// Key The KISE key content
		Key string `json:"key"`

		// Title Title or name for the KISE key
		Title string `json:"title"`

		// UpdatedAt Timestamp when the KISE key was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// User The user this KISE key belongs to
		User struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		} `json:"user"`

		// Uuid Unique identifier for the KISE key
		Uuid string `json:"uuid"`

		// Workspace The workspace this KISE key belongs to
		Workspace string `json:"workspace"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateUserKiseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserKiseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserKiseKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserKiseKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserKiseKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreatedAt Timestamp when the user was created
		CreatedAt time.Time `json:"created_at"`

		// Email Email address of the user
		Email string `json:"email"`

		// Name Full name of the user
		Name string `json:"name"`

		// UpdatedAt Timestamp when the user was last updated
		UpdatedAt time.Time `json:"updated_at"`

		// Uuid Unique identifier for the user
		Uuid string `json:"uuid"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r SuspendUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenIdTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken OAuth 2.0 access token
		AccessToken string `json:"access_token"`

		// ExpiresIn Number of seconds until the token expires
		ExpiresIn int `json:"expires_in"`

		// IdToken OpenID Connect ID token
		IdToken *string `json:"id_token,omitempty"`

		// RefreshToken OAuth 2.0 refresh token
		RefreshToken *string `json:"refresh_token,omitempty"`

		// TokenType Type of token, typically 'Bearer'
		TokenType string `json:"token_type"`
	}
	JSON400 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON401 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
	JSON403 *struct {
		Code    int `json:"code"`
		Message struct {
			Detail string `json:"detail"`
		} `json:"message"`
		Reason string `json:"reason"`
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOpenIdTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenIdTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AcceptInvitationWithBodyWithResponse request with arbitrary body returning *AcceptInvitationResponse
func (c *ClientWithResponses) AcceptInvitationWithBodyWithResponse(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error) {
	rsp, err := c.AcceptInvitationWithBody(ctx, token, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInvitationResponse(rsp)
}

func (c *ClientWithResponses) AcceptInvitationWithResponse(ctx context.Context, token string, body AcceptInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*AcceptInvitationResponse, error) {
	rsp, err := c.AcceptInvitation(ctx, token, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptInvitationResponse(rsp)
}

// CreateAuthTokenWithCredWithBodyWithResponse request with arbitrary body returning *CreateAuthTokenWithCredResponse
func (c *ClientWithResponses) CreateAuthTokenWithCredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithCredResponse, error) {
	rsp, err := c.CreateAuthTokenWithCredWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenWithCredResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthTokenWithCredWithResponse(ctx context.Context, body CreateAuthTokenWithCredJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithCredResponse, error) {
	rsp, err := c.CreateAuthTokenWithCred(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenWithCredResponse(rsp)
}

// CreateAuthTokenWithChallengeWithBodyWithResponse request with arbitrary body returning *CreateAuthTokenWithChallengeResponse
func (c *ClientWithResponses) CreateAuthTokenWithChallengeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithChallengeResponse, error) {
	rsp, err := c.CreateAuthTokenWithChallengeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenWithChallengeResponse(rsp)
}

func (c *ClientWithResponses) CreateAuthTokenWithChallengeWithResponse(ctx context.Context, body CreateAuthTokenWithChallengeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuthTokenWithChallengeResponse, error) {
	rsp, err := c.CreateAuthTokenWithChallenge(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthTokenWithChallengeResponse(rsp)
}

// ListDetailedGroupsWithResponse request returning *ListDetailedGroupsResponse
func (c *ClientWithResponses) ListDetailedGroupsWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedGroupsResponse, error) {
	rsp, err := c.ListDetailedGroups(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDetailedGroupsResponse(rsp)
}

// GetDetailedGroupWithResponse request returning *GetDetailedGroupResponse
func (c *ClientWithResponses) GetDetailedGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*GetDetailedGroupResponse, error) {
	rsp, err := c.GetDetailedGroup(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDetailedGroupResponse(rsp)
}

// ListDetailedServiceUsersWithResponse request returning *ListDetailedServiceUsersResponse
func (c *ClientWithResponses) ListDetailedServiceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedServiceUsersResponse, error) {
	rsp, err := c.ListDetailedServiceUsers(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDetailedServiceUsersResponse(rsp)
}

// GetDetailedServiceUserWithResponse request returning *GetDetailedServiceUserResponse
func (c *ClientWithResponses) GetDetailedServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*GetDetailedServiceUserResponse, error) {
	rsp, err := c.GetDetailedServiceUser(ctx, workspaceUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDetailedServiceUserResponse(rsp)
}

// ListDetailedWorkspaceUsersWithResponse request returning *ListDetailedWorkspaceUsersResponse
func (c *ClientWithResponses) ListDetailedWorkspaceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListDetailedWorkspaceUsersResponse, error) {
	rsp, err := c.ListDetailedWorkspaceUsers(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDetailedWorkspaceUsersResponse(rsp)
}

// GetDetailedWorkspaceUserWithResponse request returning *GetDetailedWorkspaceUserResponse
func (c *ClientWithResponses) GetDetailedWorkspaceUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*GetDetailedWorkspaceUserResponse, error) {
	rsp, err := c.GetDetailedWorkspaceUser(ctx, workspaceUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDetailedWorkspaceUserResponse(rsp)
}

// GetIamV1ApiV1HealthzWithResponse request returning *GetIamV1ApiV1HealthzResponse
func (c *ClientWithResponses) GetIamV1ApiV1HealthzWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIamV1ApiV1HealthzResponse, error) {
	rsp, err := c.GetIamV1ApiV1Healthz(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIamV1ApiV1HealthzResponse(rsp)
}

// GetThirdPartyAccessTokenWithBodyWithResponse request with arbitrary body returning *GetThirdPartyAccessTokenResponse
func (c *ClientWithResponses) GetThirdPartyAccessTokenWithBodyWithResponse(ctx context.Context, organizationUUID string, thirdPartyUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetThirdPartyAccessTokenResponse, error) {
	rsp, err := c.GetThirdPartyAccessTokenWithBody(ctx, organizationUUID, thirdPartyUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThirdPartyAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) GetThirdPartyAccessTokenWithResponse(ctx context.Context, organizationUUID string, thirdPartyUUID string, body GetThirdPartyAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetThirdPartyAccessTokenResponse, error) {
	rsp, err := c.GetThirdPartyAccessToken(ctx, organizationUUID, thirdPartyUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThirdPartyAccessTokenResponse(rsp)
}

// ChangePasswordWithBodyWithResponse request with arbitrary body returning *ChangePasswordResponse
func (c *ClientWithResponses) ChangePasswordWithBodyWithResponse(ctx context.Context, token string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePasswordWithBody(ctx, token, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

func (c *ClientWithResponses) ChangePasswordWithResponse(ctx context.Context, token string, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePassword(ctx, token, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// BulkCanUserWithBodyWithResponse request with arbitrary body returning *BulkCanUserResponse
func (c *ClientWithResponses) BulkCanUserWithBodyWithResponse(ctx context.Context, userUUID string, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCanUserResponse, error) {
	rsp, err := c.BulkCanUserWithBody(ctx, userUUID, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCanUserResponse(rsp)
}

func (c *ClientWithResponses) BulkCanUserWithResponse(ctx context.Context, userUUID string, workspaceUUID string, body BulkCanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCanUserResponse, error) {
	rsp, err := c.BulkCanUser(ctx, userUUID, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCanUserResponse(rsp)
}

// DisableUserOtpWithResponse request returning *DisableUserOtpResponse
func (c *ClientWithResponses) DisableUserOtpWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*DisableUserOtpResponse, error) {
	rsp, err := c.DisableUserOtp(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableUserOtpResponse(rsp)
}

// GetUserOtpStatusWithResponse request returning *GetUserOtpStatusResponse
func (c *ClientWithResponses) GetUserOtpStatusWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*GetUserOtpStatusResponse, error) {
	rsp, err := c.GetUserOtpStatus(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOtpStatusResponse(rsp)
}

// EnableUserOtpWithBodyWithResponse request with arbitrary body returning *EnableUserOtpResponse
func (c *ClientWithResponses) EnableUserOtpWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableUserOtpResponse, error) {
	rsp, err := c.EnableUserOtpWithBody(ctx, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableUserOtpResponse(rsp)
}

func (c *ClientWithResponses) EnableUserOtpWithResponse(ctx context.Context, userUUID string, body EnableUserOtpJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableUserOtpResponse, error) {
	rsp, err := c.EnableUserOtp(ctx, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableUserOtpResponse(rsp)
}

// ListUserPublicKeysWithResponse request returning *ListUserPublicKeysResponse
func (c *ClientWithResponses) ListUserPublicKeysWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserPublicKeysResponse, error) {
	rsp, err := c.ListUserPublicKeys(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPublicKeysResponse(rsp)
}

// CreateUserPublicKeyWithBodyWithResponse request with arbitrary body returning *CreateUserPublicKeyResponse
func (c *ClientWithResponses) CreateUserPublicKeyWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserPublicKeyResponse, error) {
	rsp, err := c.CreateUserPublicKeyWithBody(ctx, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserPublicKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateUserPublicKeyWithResponse(ctx context.Context, userUUID string, body CreateUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserPublicKeyResponse, error) {
	rsp, err := c.CreateUserPublicKey(ctx, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserPublicKeyResponse(rsp)
}

// DeleteUserPublicKeyWithResponse request returning *DeleteUserPublicKeyResponse
func (c *ClientWithResponses) DeleteUserPublicKeyWithResponse(ctx context.Context, userUUID string, resourceId string, reqEditors ...RequestEditorFn) (*DeleteUserPublicKeyResponse, error) {
	rsp, err := c.DeleteUserPublicKey(ctx, userUUID, resourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserPublicKeyResponse(rsp)
}

// ListUserTokensWithResponse request returning *ListUserTokensResponse
func (c *ClientWithResponses) ListUserTokensWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserTokensResponse, error) {
	rsp, err := c.ListUserTokens(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserTokensResponse(rsp)
}

// CreateUserTokenWithBodyWithResponse request with arbitrary body returning *CreateUserTokenResponse
func (c *ClientWithResponses) CreateUserTokenWithBodyWithResponse(ctx context.Context, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error) {
	rsp, err := c.CreateUserTokenWithBody(ctx, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateUserTokenWithResponse(ctx context.Context, userUUID string, body CreateUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserTokenResponse, error) {
	rsp, err := c.CreateUserToken(ctx, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserTokenResponse(rsp)
}

// DeleteUserTokenWithResponse request returning *DeleteUserTokenResponse
func (c *ClientWithResponses) DeleteUserTokenWithResponse(ctx context.Context, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error) {
	rsp, err := c.DeleteUserToken(ctx, userUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTokenResponse(rsp)
}

// ListUserWorkspacesWithResponse request returning *ListUserWorkspacesResponse
func (c *ClientWithResponses) ListUserWorkspacesWithResponse(ctx context.Context, userUUID string, reqEditors ...RequestEditorFn) (*ListUserWorkspacesResponse, error) {
	rsp, err := c.ListUserWorkspaces(ctx, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserWorkspacesResponse(rsp)
}

// ListBackupKeysWithResponse request returning *ListBackupKeysResponse
func (c *ClientWithResponses) ListBackupKeysWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListBackupKeysResponse, error) {
	rsp, err := c.ListBackupKeys(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBackupKeysResponse(rsp)
}

// CreateBackupKeyWithBodyWithResponse request with arbitrary body returning *CreateBackupKeyResponse
func (c *ClientWithResponses) CreateBackupKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupKeyResponse, error) {
	rsp, err := c.CreateBackupKeyWithBody(ctx, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateBackupKeyWithResponse(ctx context.Context, workspaceUUID string, body CreateBackupKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupKeyResponse, error) {
	rsp, err := c.CreateBackupKey(ctx, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupKeyResponse(rsp)
}

// DeleteBackupKeyWithResponse request returning *DeleteBackupKeyResponse
func (c *ClientWithResponses) DeleteBackupKeyWithResponse(ctx context.Context, workspaceUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteBackupKeyResponse, error) {
	rsp, err := c.DeleteBackupKey(ctx, workspaceUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupKeyResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, workspaceUUID string, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, workspaceUUID, groupUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, workspaceUUID, groupUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// BulkAddRolesToGroupWithResponse request returning *BulkAddRolesToGroupResponse
func (c *ClientWithResponses) BulkAddRolesToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*BulkAddRolesToGroupResponse, error) {
	rsp, err := c.BulkAddRolesToGroup(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddRolesToGroupResponse(rsp)
}

// BulkAddServiceUsersToGroupWithBodyWithResponse request with arbitrary body returning *BulkAddServiceUsersToGroupResponse
func (c *ClientWithResponses) BulkAddServiceUsersToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToGroupResponse, error) {
	rsp, err := c.BulkAddServiceUsersToGroupWithBody(ctx, workspaceUUID, groupUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddServiceUsersToGroupResponse(rsp)
}

func (c *ClientWithResponses) BulkAddServiceUsersToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddServiceUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToGroupResponse, error) {
	rsp, err := c.BulkAddServiceUsersToGroup(ctx, workspaceUUID, groupUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddServiceUsersToGroupResponse(rsp)
}

// BulkAddUsersToGroupWithBodyWithResponse request with arbitrary body returning *BulkAddUsersToGroupResponse
func (c *ClientWithResponses) BulkAddUsersToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddUsersToGroupResponse, error) {
	rsp, err := c.BulkAddUsersToGroupWithBody(ctx, workspaceUUID, groupUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddUsersToGroupResponse(rsp)
}

func (c *ClientWithResponses) BulkAddUsersToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, body BulkAddUsersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddUsersToGroupResponse, error) {
	rsp, err := c.BulkAddUsersToGroup(ctx, workspaceUUID, groupUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddUsersToGroupResponse(rsp)
}

// ListGroupRolesWithResponse request returning *ListGroupRolesResponse
func (c *ClientWithResponses) ListGroupRolesWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupRolesResponse, error) {
	rsp, err := c.ListGroupRoles(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupRolesResponse(rsp)
}

// ListGroupServiceUsersWithResponse request returning *ListGroupServiceUsersResponse
func (c *ClientWithResponses) ListGroupServiceUsersWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupServiceUsersResponse, error) {
	rsp, err := c.ListGroupServiceUsers(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupServiceUsersResponse(rsp)
}

// RemoveServiceUserFromGroupWithResponse request returning *RemoveServiceUserFromGroupResponse
func (c *ClientWithResponses) RemoveServiceUserFromGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*RemoveServiceUserFromGroupResponse, error) {
	rsp, err := c.RemoveServiceUserFromGroup(ctx, workspaceUUID, groupUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveServiceUserFromGroupResponse(rsp)
}

// AddServiceUserToGroupWithBodyWithResponse request with arbitrary body returning *AddServiceUserToGroupResponse
func (c *ClientWithResponses) AddServiceUserToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddServiceUserToGroupResponse, error) {
	rsp, err := c.AddServiceUserToGroupWithBody(ctx, workspaceUUID, groupUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddServiceUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddServiceUserToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, serviceUserUUID string, body AddServiceUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddServiceUserToGroupResponse, error) {
	rsp, err := c.AddServiceUserToGroup(ctx, workspaceUUID, groupUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddServiceUserToGroupResponse(rsp)
}

// ListGroupUsersWithResponse request returning *ListGroupUsersResponse
func (c *ClientWithResponses) ListGroupUsersWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error) {
	rsp, err := c.ListGroupUsers(ctx, workspaceUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupUsersResponse(rsp)
}

// RemoveUserFromGroupWithResponse request returning *RemoveUserFromGroupResponse
func (c *ClientWithResponses) RemoveUserFromGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveUserFromGroupResponse, error) {
	rsp, err := c.RemoveUserFromGroup(ctx, workspaceUUID, groupUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromGroupResponse(rsp)
}

// AddUserToGroupWithBodyWithResponse request with arbitrary body returning *AddUserToGroupResponse
func (c *ClientWithResponses) AddUserToGroupWithBodyWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroupWithBody(ctx, workspaceUUID, groupUUID, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddUserToGroupWithResponse(ctx context.Context, workspaceUUID string, groupUUID string, userUUID string, body AddUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToGroupResponse, error) {
	rsp, err := c.AddUserToGroup(ctx, workspaceUUID, groupUUID, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToGroupResponse(rsp)
}

// InviteUsersToWorkspaceWithBodyWithResponse request with arbitrary body returning *InviteUsersToWorkspaceResponse
func (c *ClientWithResponses) InviteUsersToWorkspaceWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InviteUsersToWorkspaceResponse, error) {
	rsp, err := c.InviteUsersToWorkspaceWithBody(ctx, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersToWorkspaceResponse(rsp)
}

func (c *ClientWithResponses) InviteUsersToWorkspaceWithResponse(ctx context.Context, workspaceUUID string, body InviteUsersToWorkspaceJSONRequestBody, reqEditors ...RequestEditorFn) (*InviteUsersToWorkspaceResponse, error) {
	rsp, err := c.InviteUsersToWorkspace(ctx, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInviteUsersToWorkspaceResponse(rsp)
}

// ListServiceUserKiseKeysWithResponse request returning *ListServiceUserKiseKeysResponse
func (c *ClientWithResponses) ListServiceUserKiseKeysWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserKiseKeysResponse, error) {
	rsp, err := c.ListServiceUserKiseKeys(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceUserKiseKeysResponse(rsp)
}

// ListRolesWithResponse request returning *ListRolesResponse
func (c *ClientWithResponses) ListRolesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListRolesResponse, error) {
	rsp, err := c.ListRoles(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRolesResponse(rsp)
}

// CreateRoleWithResponse request returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, workspaceUUID, roleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, workspaceUUID, roleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// BulkAddRulesToRoleWithBodyWithResponse request with arbitrary body returning *BulkAddRulesToRoleResponse
func (c *ClientWithResponses) BulkAddRulesToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddRulesToRoleResponse, error) {
	rsp, err := c.BulkAddRulesToRoleWithBody(ctx, workspaceUUID, roleUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddRulesToRoleResponse(rsp)
}

func (c *ClientWithResponses) BulkAddRulesToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddRulesToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddRulesToRoleResponse, error) {
	rsp, err := c.BulkAddRulesToRole(ctx, workspaceUUID, roleUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddRulesToRoleResponse(rsp)
}

// BulkAddServiceUsersToRoleWithBodyWithResponse request with arbitrary body returning *BulkAddServiceUsersToRoleResponse
func (c *ClientWithResponses) BulkAddServiceUsersToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToRoleResponse, error) {
	rsp, err := c.BulkAddServiceUsersToRoleWithBody(ctx, workspaceUUID, roleUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddServiceUsersToRoleResponse(rsp)
}

func (c *ClientWithResponses) BulkAddServiceUsersToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddServiceUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddServiceUsersToRoleResponse, error) {
	rsp, err := c.BulkAddServiceUsersToRole(ctx, workspaceUUID, roleUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddServiceUsersToRoleResponse(rsp)
}

// BulkAddUsersToRoleWithBodyWithResponse request with arbitrary body returning *BulkAddUsersToRoleResponse
func (c *ClientWithResponses) BulkAddUsersToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddUsersToRoleResponse, error) {
	rsp, err := c.BulkAddUsersToRoleWithBody(ctx, workspaceUUID, roleUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddUsersToRoleResponse(rsp)
}

func (c *ClientWithResponses) BulkAddUsersToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, body BulkAddUsersToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddUsersToRoleResponse, error) {
	rsp, err := c.BulkAddUsersToRole(ctx, workspaceUUID, roleUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddUsersToRoleResponse(rsp)
}

// RemoveRoleFromGroupWithResponse request returning *RemoveRoleFromGroupResponse
func (c *ClientWithResponses) RemoveRoleFromGroupWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, groupUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromGroupResponse, error) {
	rsp, err := c.RemoveRoleFromGroup(ctx, workspaceUUID, roleUUID, groupUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRoleFromGroupResponse(rsp)
}

// ListRoleRulesWithResponse request returning *ListRoleRulesResponse
func (c *ClientWithResponses) ListRoleRulesWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListRoleRulesResponse, error) {
	rsp, err := c.ListRoleRules(ctx, workspaceUUID, roleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRoleRulesResponse(rsp)
}

// RemoveRuleFromRoleWithResponse request returning *RemoveRuleFromRoleResponse
func (c *ClientWithResponses) RemoveRuleFromRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*RemoveRuleFromRoleResponse, error) {
	rsp, err := c.RemoveRuleFromRole(ctx, workspaceUUID, roleUUID, ruleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRuleFromRoleResponse(rsp)
}

// AddRuleToRoleWithBodyWithResponse request with arbitrary body returning *AddRuleToRoleResponse
func (c *ClientWithResponses) AddRuleToRoleWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuleToRoleResponse, error) {
	rsp, err := c.AddRuleToRoleWithBody(ctx, workspaceUUID, roleUUID, ruleUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuleToRoleResponse(rsp)
}

func (c *ClientWithResponses) AddRuleToRoleWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, ruleUUID string, body AddRuleToRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuleToRoleResponse, error) {
	rsp, err := c.AddRuleToRole(ctx, workspaceUUID, roleUUID, ruleUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuleToRoleResponse(rsp)
}

// ListServiceUsersRoleBindingsWithResponse request returning *ListServiceUsersRoleBindingsResponse
func (c *ClientWithResponses) ListServiceUsersRoleBindingsWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListServiceUsersRoleBindingsResponse, error) {
	rsp, err := c.ListServiceUsersRoleBindings(ctx, workspaceUUID, roleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceUsersRoleBindingsResponse(rsp)
}

// RemoveRoleFromServiceUserWithResponse request returning *RemoveRoleFromServiceUserResponse
func (c *ClientWithResponses) RemoveRoleFromServiceUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromServiceUserResponse, error) {
	rsp, err := c.RemoveRoleFromServiceUser(ctx, workspaceUUID, roleUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRoleFromServiceUserResponse(rsp)
}

// GetServiceUserRoleBindingWithResponse request returning *GetServiceUserRoleBindingResponse
func (c *ClientWithResponses) GetServiceUserRoleBindingWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*GetServiceUserRoleBindingResponse, error) {
	rsp, err := c.GetServiceUserRoleBinding(ctx, workspaceUUID, roleUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceUserRoleBindingResponse(rsp)
}

// AssignRoleToServiceUserWithBodyWithResponse request with arbitrary body returning *AssignRoleToServiceUserResponse
func (c *ClientWithResponses) AssignRoleToServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToServiceUserResponse, error) {
	rsp, err := c.AssignRoleToServiceUserWithBody(ctx, workspaceUUID, roleUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToServiceUserResponse(rsp)
}

func (c *ClientWithResponses) AssignRoleToServiceUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, serviceUserUUID string, body AssignRoleToServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToServiceUserResponse, error) {
	rsp, err := c.AssignRoleToServiceUser(ctx, workspaceUUID, roleUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToServiceUserResponse(rsp)
}

// ListUsersRoleBindingsWithResponse request returning *ListUsersRoleBindingsResponse
func (c *ClientWithResponses) ListUsersRoleBindingsWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, reqEditors ...RequestEditorFn) (*ListUsersRoleBindingsResponse, error) {
	rsp, err := c.ListUsersRoleBindings(ctx, workspaceUUID, roleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersRoleBindingsResponse(rsp)
}

// RemoveRoleFromUserWithResponse request returning *RemoveRoleFromUserResponse
func (c *ClientWithResponses) RemoveRoleFromUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveRoleFromUserResponse, error) {
	rsp, err := c.RemoveRoleFromUser(ctx, workspaceUUID, roleUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRoleFromUserResponse(rsp)
}

// GetUserRoleBindingWithResponse request returning *GetUserRoleBindingResponse
func (c *ClientWithResponses) GetUserRoleBindingWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, reqEditors ...RequestEditorFn) (*GetUserRoleBindingResponse, error) {
	rsp, err := c.GetUserRoleBinding(ctx, workspaceUUID, roleUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserRoleBindingResponse(rsp)
}

// AssignRoleToUserWithBodyWithResponse request with arbitrary body returning *AssignRoleToUserResponse
func (c *ClientWithResponses) AssignRoleToUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error) {
	rsp, err := c.AssignRoleToUserWithBody(ctx, workspaceUUID, roleUUID, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToUserResponse(rsp)
}

func (c *ClientWithResponses) AssignRoleToUserWithResponse(ctx context.Context, workspaceUUID string, roleUUID string, userUUID string, body AssignRoleToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AssignRoleToUserResponse, error) {
	rsp, err := c.AssignRoleToUser(ctx, workspaceUUID, roleUUID, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssignRoleToUserResponse(rsp)
}

// ListRulesWithResponse request returning *ListRulesResponse
func (c *ClientWithResponses) ListRulesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListRulesResponse, error) {
	rsp, err := c.ListRules(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRulesResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, workspaceUUID string, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, workspaceUUID, ruleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleWithResponse request returning *GetRuleResponse
func (c *ClientWithResponses) GetRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*GetRuleResponse, error) {
	rsp, err := c.GetRule(ctx, workspaceUUID, ruleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, workspaceUUID, ruleUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, workspaceUUID, ruleUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// ListRuleRolesWithResponse request returning *ListRuleRolesResponse
func (c *ClientWithResponses) ListRuleRolesWithResponse(ctx context.Context, workspaceUUID string, ruleUUID string, reqEditors ...RequestEditorFn) (*ListRuleRolesResponse, error) {
	rsp, err := c.ListRuleRoles(ctx, workspaceUUID, ruleUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRuleRolesResponse(rsp)
}

// ListServiceUsersWithResponse request returning *ListServiceUsersResponse
func (c *ClientWithResponses) ListServiceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServiceUsersResponse, error) {
	rsp, err := c.ListServiceUsers(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceUsersResponse(rsp)
}

// CreateServiceUserWithBodyWithResponse request with arbitrary body returning *CreateServiceUserResponse
func (c *ClientWithResponses) CreateServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserResponse, error) {
	rsp, err := c.CreateServiceUserWithBody(ctx, workspaceUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceUserWithResponse(ctx context.Context, workspaceUUID string, body CreateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserResponse, error) {
	rsp, err := c.CreateServiceUser(ctx, workspaceUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserResponse(rsp)
}

// DeleteServiceUserWithResponse request returning *DeleteServiceUserResponse
func (c *ClientWithResponses) DeleteServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserResponse, error) {
	rsp, err := c.DeleteServiceUser(ctx, workspaceUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceUserResponse(rsp)
}

// UpdateServiceUserWithBodyWithResponse request with arbitrary body returning *UpdateServiceUserResponse
func (c *ClientWithResponses) UpdateServiceUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceUserResponse, error) {
	rsp, err := c.UpdateServiceUserWithBody(ctx, workspaceUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceUserWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body UpdateServiceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceUserResponse, error) {
	rsp, err := c.UpdateServiceUser(ctx, workspaceUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceUserResponse(rsp)
}

// CreateServiceUserKiseKeyWithBodyWithResponse request with arbitrary body returning *CreateServiceUserKiseKeyResponse
func (c *ClientWithResponses) CreateServiceUserKiseKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserKiseKeyResponse, error) {
	rsp, err := c.CreateServiceUserKiseKeyWithBody(ctx, workspaceUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserKiseKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserKiseKeyResponse, error) {
	rsp, err := c.CreateServiceUserKiseKey(ctx, workspaceUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserKiseKeyResponse(rsp)
}

// DeleteServiceUserKiseKeyWithResponse request returning *DeleteServiceUserKiseKeyResponse
func (c *ClientWithResponses) DeleteServiceUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserKiseKeyResponse, error) {
	rsp, err := c.DeleteServiceUserKiseKey(ctx, workspaceUUID, serviceUserUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceUserKiseKeyResponse(rsp)
}

// ListServiceUserPublicKeysWithResponse request returning *ListServiceUserPublicKeysResponse
func (c *ClientWithResponses) ListServiceUserPublicKeysWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserPublicKeysResponse, error) {
	rsp, err := c.ListServiceUserPublicKeys(ctx, workspaceUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceUserPublicKeysResponse(rsp)
}

// CreateServiceUserPublicKeyWithBodyWithResponse request with arbitrary body returning *CreateServiceUserPublicKeyResponse
func (c *ClientWithResponses) CreateServiceUserPublicKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserPublicKeyResponse, error) {
	rsp, err := c.CreateServiceUserPublicKeyWithBody(ctx, workspaceUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserPublicKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceUserPublicKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserPublicKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserPublicKeyResponse, error) {
	rsp, err := c.CreateServiceUserPublicKey(ctx, workspaceUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserPublicKeyResponse(rsp)
}

// DeleteServiceUserPublicKeyWithResponse request returning *DeleteServiceUserPublicKeyResponse
func (c *ClientWithResponses) DeleteServiceUserPublicKeyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserPublicKeyResponse, error) {
	rsp, err := c.DeleteServiceUserPublicKey(ctx, workspaceUUID, serviceUserUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceUserPublicKeyResponse(rsp)
}

// ListServiceUserTokensWithResponse request returning *ListServiceUserTokensResponse
func (c *ClientWithResponses) ListServiceUserTokensWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, reqEditors ...RequestEditorFn) (*ListServiceUserTokensResponse, error) {
	rsp, err := c.ListServiceUserTokens(ctx, workspaceUUID, serviceUserUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceUserTokensResponse(rsp)
}

// CreateServiceUserTokenWithBodyWithResponse request with arbitrary body returning *CreateServiceUserTokenResponse
func (c *ClientWithResponses) CreateServiceUserTokenWithBodyWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceUserTokenResponse, error) {
	rsp, err := c.CreateServiceUserTokenWithBody(ctx, workspaceUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceUserTokenWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, body CreateServiceUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceUserTokenResponse, error) {
	rsp, err := c.CreateServiceUserToken(ctx, workspaceUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceUserTokenResponse(rsp)
}

// DeleteServiceUserTokenWithResponse request returning *DeleteServiceUserTokenResponse
func (c *ClientWithResponses) DeleteServiceUserTokenWithResponse(ctx context.Context, workspaceUUID string, serviceUserUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteServiceUserTokenResponse, error) {
	rsp, err := c.DeleteServiceUserToken(ctx, workspaceUUID, serviceUserUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceUserTokenResponse(rsp)
}

// ListServicesWithResponse request returning *ListServicesResponse
func (c *ClientWithResponses) ListServicesWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListServicesResponse, error) {
	rsp, err := c.ListServices(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicesResponse(rsp)
}

// BulkRefreshThirdPartyTokensWithBodyWithResponse request with arbitrary body returning *BulkRefreshThirdPartyTokensResponse
func (c *ClientWithResponses) BulkRefreshThirdPartyTokensWithBodyWithResponse(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkRefreshThirdPartyTokensResponse, error) {
	rsp, err := c.BulkRefreshThirdPartyTokensWithBody(ctx, workspaceUUID, thirdPartyUUID, serviceUserUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkRefreshThirdPartyTokensResponse(rsp)
}

func (c *ClientWithResponses) BulkRefreshThirdPartyTokensWithResponse(ctx context.Context, workspaceUUID string, thirdPartyUUID string, serviceUserUUID string, body BulkRefreshThirdPartyTokensJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkRefreshThirdPartyTokensResponse, error) {
	rsp, err := c.BulkRefreshThirdPartyTokens(ctx, workspaceUUID, thirdPartyUUID, serviceUserUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkRefreshThirdPartyTokensResponse(rsp)
}

// ListWorkspaceUsersWithResponse request returning *ListWorkspaceUsersResponse
func (c *ClientWithResponses) ListWorkspaceUsersWithResponse(ctx context.Context, workspaceUUID string, reqEditors ...RequestEditorFn) (*ListWorkspaceUsersResponse, error) {
	rsp, err := c.ListWorkspaceUsers(ctx, workspaceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkspaceUsersResponse(rsp)
}

// RemoveUserFromWorkspaceWithResponse request returning *RemoveUserFromWorkspaceResponse
func (c *ClientWithResponses) RemoveUserFromWorkspaceWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*RemoveUserFromWorkspaceResponse, error) {
	rsp, err := c.RemoveUserFromWorkspace(ctx, workspaceUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromWorkspaceResponse(rsp)
}

// AllowUserWithBodyWithResponse request with arbitrary body returning *AllowUserResponse
func (c *ClientWithResponses) AllowUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AllowUserResponse, error) {
	rsp, err := c.AllowUserWithBody(ctx, workspaceUUID, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowUserResponse(rsp)
}

func (c *ClientWithResponses) AllowUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body AllowUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AllowUserResponse, error) {
	rsp, err := c.AllowUser(ctx, workspaceUUID, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllowUserResponse(rsp)
}

// ListUserKiseKeysWithResponse request returning *ListUserKiseKeysResponse
func (c *ClientWithResponses) ListUserKiseKeysWithResponse(ctx context.Context, workspaceUUID string, userUUID string, reqEditors ...RequestEditorFn) (*ListUserKiseKeysResponse, error) {
	rsp, err := c.ListUserKiseKeys(ctx, workspaceUUID, userUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserKiseKeysResponse(rsp)
}

// CreateUserKiseKeyWithBodyWithResponse request with arbitrary body returning *CreateUserKiseKeyResponse
func (c *ClientWithResponses) CreateUserKiseKeyWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserKiseKeyResponse, error) {
	rsp, err := c.CreateUserKiseKeyWithBody(ctx, workspaceUUID, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserKiseKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body CreateUserKiseKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserKiseKeyResponse, error) {
	rsp, err := c.CreateUserKiseKey(ctx, workspaceUUID, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserKiseKeyResponse(rsp)
}

// DeleteUserKiseKeyWithResponse request returning *DeleteUserKiseKeyResponse
func (c *ClientWithResponses) DeleteUserKiseKeyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, resourceUUID string, reqEditors ...RequestEditorFn) (*DeleteUserKiseKeyResponse, error) {
	rsp, err := c.DeleteUserKiseKey(ctx, workspaceUUID, userUUID, resourceUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserKiseKeyResponse(rsp)
}

// SuspendUserWithBodyWithResponse request with arbitrary body returning *SuspendUserResponse
func (c *ClientWithResponses) SuspendUserWithBodyWithResponse(ctx context.Context, workspaceUUID string, userUUID string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SuspendUserResponse, error) {
	rsp, err := c.SuspendUserWithBody(ctx, workspaceUUID, userUUID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendUserResponse(rsp)
}

func (c *ClientWithResponses) SuspendUserWithResponse(ctx context.Context, workspaceUUID string, userUUID string, body SuspendUserJSONRequestBody, reqEditors ...RequestEditorFn) (*SuspendUserResponse, error) {
	rsp, err := c.SuspendUser(ctx, workspaceUUID, userUUID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendUserResponse(rsp)
}

// GetOpenIdTokenWithBodyWithResponse request with arbitrary body returning *GetOpenIdTokenResponse
func (c *ClientWithResponses) GetOpenIdTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetOpenIdTokenResponse, error) {
	rsp, err := c.GetOpenIdTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIdTokenResponse(rsp)
}

func (c *ClientWithResponses) GetOpenIdTokenWithResponse(ctx context.Context, body GetOpenIdTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*GetOpenIdTokenResponse, error) {
	rsp, err := c.GetOpenIdToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIdTokenResponse(rsp)
}

// ParseAcceptInvitationResponse parses an HTTP response from a AcceptInvitationWithResponse call
func ParseAcceptInvitationResponse(rsp *http.Response) (*AcceptInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAuthTokenWithCredResponse parses an HTTP response from a CreateAuthTokenWithCredWithResponse call
func ParseCreateAuthTokenWithCredResponse(rsp *http.Response) (*CreateAuthTokenWithCredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthTokenWithCredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ChallengeToken Token to be used when responding to the challenge
			ChallengeToken string `json:"challenge_token"`

			// ChallengeType Type of challenge (e.g., 'otp', 'sms')
			ChallengeType string `json:"challenge_type"`

			// Message Human-readable message about the challenge
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ExpiresAt Token expiration timestamp
			ExpiresAt time.Time `json:"expires_at"`

			// Token Authentication token
			Token string `json:"token"`

			// UserUuid UUID of the authenticated user
			UserUuid string `json:"user_uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAuthTokenWithChallengeResponse parses an HTTP response from a CreateAuthTokenWithChallengeWithResponse call
func ParseCreateAuthTokenWithChallengeResponse(rsp *http.Response) (*CreateAuthTokenWithChallengeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthTokenWithChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ChallengeToken Token to be used when responding to the challenge
			ChallengeToken string `json:"challenge_token"`

			// ChallengeType Type of challenge (e.g., 'otp', 'sms')
			ChallengeType string `json:"challenge_type"`

			// Message Human-readable message about the challenge
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ExpiresAt Token expiration timestamp
			ExpiresAt time.Time `json:"expires_at"`

			// Token Authentication token
			Token string `json:"token"`

			// UserUuid UUID of the authenticated user
			UserUuid string `json:"user_uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListDetailedGroupsResponse parses an HTTP response from a ListDetailedGroupsWithResponse call
func ParseListDetailedGroupsResponse(rsp *http.Response) (*ListDetailedGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDetailedGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// Roles List of roles assigned to the group
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// ServiceUsers List of service user members in the group
			ServiceUsers []struct {
				// CreatedAt Timestamp when the member was added to the group
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the member
				Email string `json:"email"`

				// Name Name of the member
				Name string `json:"name"`

				// Uuid Unique identifier for the member
				Uuid string `json:"uuid"`
			} `json:"service_users"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Users List of user members in the group
			Users []struct {
				// CreatedAt Timestamp when the member was added to the group
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the member
				Email string `json:"email"`

				// Name Name of the member
				Name string `json:"name"`

				// Uuid Unique identifier for the member
				Uuid string `json:"uuid"`
			} `json:"users"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDetailedGroupResponse parses an HTTP response from a GetDetailedGroupWithResponse call
func ParseGetDetailedGroupResponse(rsp *http.Response) (*GetDetailedGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDetailedGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// Roles List of roles assigned to the group
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// ServiceUsers List of service user members in the group
			ServiceUsers []struct {
				// CreatedAt Timestamp when the member was added to the group
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the member
				Email string `json:"email"`

				// Name Name of the member
				Name string `json:"name"`

				// Uuid Unique identifier for the member
				Uuid string `json:"uuid"`
			} `json:"service_users"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Users List of user members in the group
			Users []struct {
				// CreatedAt Timestamp when the member was added to the group
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the member
				Email string `json:"email"`

				// Name Name of the member
				Name string `json:"name"`

				// Uuid Unique identifier for the member
				Uuid string `json:"uuid"`
			} `json:"users"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListDetailedServiceUsersResponse parses an HTTP response from a ListDetailedServiceUsersWithResponse call
func ParseListDetailedServiceUsersResponse(rsp *http.Response) (*ListDetailedServiceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDetailedServiceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the service user
			Description *string `json:"description,omitempty"`

			// Groups Groups this service user belongs to
			Groups []struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"groups"`

			// Name Name of the service user
			Name string `json:"name"`

			// Roles Roles assigned to this service user
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDetailedServiceUserResponse parses an HTTP response from a GetDetailedServiceUserWithResponse call
func ParseGetDetailedServiceUserResponse(rsp *http.Response) (*GetDetailedServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDetailedServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the service user
			Description *string `json:"description,omitempty"`

			// Groups Groups this service user belongs to
			Groups []struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"groups"`

			// Name Name of the service user
			Name string `json:"name"`

			// Roles Roles assigned to this service user
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListDetailedWorkspaceUsersResponse parses an HTTP response from a ListDetailedWorkspaceUsersWithResponse call
func ParseListDetailedWorkspaceUsersResponse(rsp *http.Response) (*ListDetailedWorkspaceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDetailedWorkspaceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the user was added to the workspace
			CreatedAt time.Time `json:"created_at"`

			// Groups Groups this user belongs to in the workspace
			Groups []struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"groups"`

			// Roles Roles assigned to this user in the workspace
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// UpdatedAt Timestamp when the user's workspace information was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Workspace The workspace the user belongs to
			Workspace struct {
				// CreatedAt Timestamp when the workspace was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the workspace
				Description *string `json:"description,omitempty"`

				// Name Name of the workspace
				Name string `json:"name"`

				// UpdatedAt Timestamp when the workspace was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the workspace
				Uuid string `json:"uuid"`
			} `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDetailedWorkspaceUserResponse parses an HTTP response from a GetDetailedWorkspaceUserWithResponse call
func ParseGetDetailedWorkspaceUserResponse(rsp *http.Response) (*GetDetailedWorkspaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDetailedWorkspaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the user was added to the workspace
			CreatedAt time.Time `json:"created_at"`

			// Groups Groups this user belongs to in the workspace
			Groups []struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"groups"`

			// Roles Roles assigned to this user in the workspace
			Roles []struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"roles"`

			// UpdatedAt Timestamp when the user's workspace information was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Workspace The workspace the user belongs to
			Workspace struct {
				// CreatedAt Timestamp when the workspace was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the workspace
				Description *string `json:"description,omitempty"`

				// Name Name of the workspace
				Name string `json:"name"`

				// UpdatedAt Timestamp when the workspace was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the workspace
				Uuid string `json:"uuid"`
			} `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetIamV1ApiV1HealthzResponse parses an HTTP response from a GetIamV1ApiV1HealthzWithResponse call
func ParseGetIamV1ApiV1HealthzResponse(rsp *http.Response) (*GetIamV1ApiV1HealthzResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIamV1ApiV1HealthzResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Caches []struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"caches"`
			Databases []struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"databases"`
			Storage struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"storage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Caches []struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"caches"`
			Databases []struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"databases"`
			Storage struct {
				Default struct {
					Ok bool `json:"ok"`
				} `json:"default"`
			} `json:"storage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetThirdPartyAccessTokenResponse parses an HTTP response from a GetThirdPartyAccessTokenWithResponse call
func ParseGetThirdPartyAccessTokenResponse(rsp *http.Response) (*GetThirdPartyAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThirdPartyAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken Access token for the third-party service
			AccessToken string `json:"access_token"`

			// ExpiresIn Number of seconds until the token expires
			ExpiresIn int `json:"expires_in"`

			// RefreshToken Refresh token for the third-party service
			RefreshToken *string `json:"refresh_token,omitempty"`

			// Scope Scope of access granted by the token
			Scope *string `json:"scope,omitempty"`

			// ThirdPartyUserId User ID in the third-party service
			ThirdPartyUserId *string `json:"third_party_user_id,omitempty"`

			// TokenType Type of token, typically 'Bearer'
			TokenType string `json:"token_type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseChangePasswordResponse parses an HTTP response from a ChangePasswordWithResponse call
func ParseChangePasswordResponse(rsp *http.Response) (*ChangePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkCanUserResponse parses an HTTP response from a BulkCanUserWithResponse call
func ParseBulkCanUserResponse(rsp *http.Response) (*BulkCanUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCanUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Actions List of actions that were checked
			Actions []string `json:"actions"`

			// Allowed Whether the user is allowed to perform the actions on the specified service and path
			Allowed bool `json:"allowed"`

			// Path The path within the service that was checked
			Path string `json:"path"`

			// Service The service name that was checked
			Service string `json:"service"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDisableUserOtpResponse parses an HTTP response from a DisableUserOtpWithResponse call
func ParseDisableUserOtpResponse(rsp *http.Response) (*DisableUserOtpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableUserOtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserOtpStatusResponse parses an HTTP response from a GetUserOtpStatusWithResponse call
func ParseGetUserOtpStatusResponse(rsp *http.Response) (*GetUserOtpStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOtpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Enabled Whether OTP is enabled for the user
			Enabled bool `json:"enabled"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEnableUserOtpResponse parses an HTTP response from a EnableUserOtpWithResponse call
func ParseEnableUserOtpResponse(rsp *http.Response) (*EnableUserOtpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableUserOtpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListUserPublicKeysResponse parses an HTTP response from a ListUserPublicKeysWithResponse call
func ParseListUserPublicKeysResponse(rsp *http.Response) (*ListUserPublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserPublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the public key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The public key content in SSH format
			Key string `json:"key"`

			// Title Title or name for the public key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the public key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user this public key belongs to
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the public key
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUserPublicKeyResponse parses an HTTP response from a CreateUserPublicKeyWithResponse call
func ParseCreateUserPublicKeyResponse(rsp *http.Response) (*CreateUserPublicKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the public key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The public key content in SSH format
			Key string `json:"key"`

			// Title Title or name for the public key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the public key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user this public key belongs to
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the public key
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteUserPublicKeyResponse parses an HTTP response from a DeleteUserPublicKeyWithResponse call
func ParseDeleteUserPublicKeyResponse(rsp *http.Response) (*DeleteUserPublicKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListUserTokensResponse parses an HTTP response from a ListUserTokensWithResponse call
func ParseListUserTokensResponse(rsp *http.Response) (*ListUserTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ExpiresAt Token expiration timestamp
			ExpiresAt time.Time `json:"expires_at"`

			// Token Authentication token
			Token string `json:"token"`

			// UserUuid UUID of the authenticated user
			UserUuid string `json:"user_uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUserTokenResponse parses an HTTP response from a CreateUserTokenWithResponse call
func ParseCreateUserTokenResponse(rsp *http.Response) (*CreateUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ExpiresAt Token expiration timestamp
			ExpiresAt time.Time `json:"expires_at"`

			// Token Authentication token
			Token string `json:"token"`

			// UserUuid UUID of the authenticated user
			UserUuid string `json:"user_uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteUserTokenResponse parses an HTTP response from a DeleteUserTokenWithResponse call
func ParseDeleteUserTokenResponse(rsp *http.Response) (*DeleteUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListUserWorkspacesResponse parses an HTTP response from a ListUserWorkspacesWithResponse call
func ParseListUserWorkspacesResponse(rsp *http.Response) (*ListUserWorkspacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserWorkspacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListBackupKeysResponse parses an HTTP response from a ListBackupKeysWithResponse call
func ParseListBackupKeysResponse(rsp *http.Response) (*ListBackupKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBackupKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the backup key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The SSH key content in SSH format
			Key string `json:"key"`

			// Title Title or name for the backup key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the backup key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the backup key
			Uuid string `json:"uuid"`

			// Workspace The workspace this backup key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateBackupKeyResponse parses an HTTP response from a CreateBackupKeyWithResponse call
func ParseCreateBackupKeyResponse(rsp *http.Response) (*CreateBackupKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the backup key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The SSH key content in SSH format
			Key string `json:"key"`

			// Title Title or name for the backup key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the backup key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the backup key
			Uuid string `json:"uuid"`

			// Workspace The workspace this backup key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteBackupKeyResponse parses an HTTP response from a DeleteBackupKeyWithResponse call
func ParseDeleteBackupKeyResponse(rsp *http.Response) (*DeleteBackupKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the group was created
			CreatedAt time.Time `json:"created_at"`

			// Description Optional description of the group's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the group
			Name string `json:"name"`

			// UpdatedAt Timestamp when the group was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the group
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddRolesToGroupResponse parses an HTTP response from a BulkAddRolesToGroupWithResponse call
func ParseBulkAddRolesToGroupResponse(rsp *http.Response) (*BulkAddRolesToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddRolesToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the role binding was created
			CreatedAt time.Time `json:"created_at"`

			// Group The group the role is bound to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// Role The role that is bound
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// UpdatedAt Timestamp when the role binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role binding
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddServiceUsersToGroupResponse parses an HTTP response from a BulkAddServiceUsersToGroupWithResponse call
func ParseBulkAddServiceUsersToGroupResponse(rsp *http.Response) (*BulkAddServiceUsersToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddServiceUsersToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the service user was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Group The group the service user was added to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// ServiceUser The service user that was added to the group
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Uuid Unique identifier for the service-user-group association
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddUsersToGroupResponse parses an HTTP response from a BulkAddUsersToGroupWithResponse call
func ParseBulkAddUsersToGroupResponse(rsp *http.Response) (*BulkAddUsersToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddUsersToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the user was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Group The group the user was added to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// User The user that was added to the group
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the user-group association
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListGroupRolesResponse parses an HTTP response from a ListGroupRolesWithResponse call
func ParseListGroupRolesResponse(rsp *http.Response) (*ListGroupRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListGroupServiceUsersResponse parses an HTTP response from a ListGroupServiceUsersWithResponse call
func ParseListGroupServiceUsersResponse(rsp *http.Response) (*ListGroupServiceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupServiceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveServiceUserFromGroupResponse parses an HTTP response from a RemoveServiceUserFromGroupWithResponse call
func ParseRemoveServiceUserFromGroupResponse(rsp *http.Response) (*RemoveServiceUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveServiceUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAddServiceUserToGroupResponse parses an HTTP response from a AddServiceUserToGroupWithResponse call
func ParseAddServiceUserToGroupResponse(rsp *http.Response) (*AddServiceUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddServiceUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the service user was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Group The group the service user was added to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// ServiceUser The service user that was added to the group
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Uuid Unique identifier for the service-user-group association
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListGroupUsersResponse parses an HTTP response from a ListGroupUsersWithResponse call
func ParseListGroupUsersResponse(rsp *http.Response) (*ListGroupUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromGroupResponse parses an HTTP response from a RemoveUserFromGroupWithResponse call
func ParseRemoveUserFromGroupResponse(rsp *http.Response) (*RemoveUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAddUserToGroupResponse parses an HTTP response from a AddUserToGroupWithResponse call
func ParseAddUserToGroupResponse(rsp *http.Response) (*AddUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the user was added to the group
			CreatedAt time.Time `json:"created_at"`

			// Group The group the user was added to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// User The user that was added to the group
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the user-group association
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseInviteUsersToWorkspaceResponse parses an HTTP response from a InviteUsersToWorkspaceWithResponse call
func ParseInviteUsersToWorkspaceResponse(rsp *http.Response) (*InviteUsersToWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InviteUsersToWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created List of users that were created
			Created []struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"created"`

			// Existing List of users that already existed
			Existing []struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"existing"`

			// Invited List of email addresses that were invited
			Invited []string `json:"invited"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServiceUserKiseKeysResponse parses an HTTP response from a ListServiceUserKiseKeysWithResponse call
func ParseListServiceUserKiseKeysResponse(rsp *http.Response) (*ListServiceUserKiseKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceUserKiseKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the KISE key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The KISE key content
			Key string `json:"key"`

			// ServiceUser The service user this KISE key belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Title Title or name for the KISE key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the KISE key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the KISE key
			Uuid string `json:"uuid"`

			// Workspace The workspace this KISE key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListRolesResponse parses an HTTP response from a ListRolesWithResponse call
func ParseListRolesResponse(rsp *http.Response) (*ListRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddRulesToRoleResponse parses an HTTP response from a BulkAddRulesToRoleWithResponse call
func ParseBulkAddRulesToRoleResponse(rsp *http.Response) (*BulkAddRulesToRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddRulesToRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the role-rule binding was created
			CreatedAt time.Time `json:"created_at"`

			// Role The role that is bound
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// Rule The rule that is bound
			Rule struct {
				// Action Action this rule controls
				Action string `json:"action"`

				// CreatedAt Timestamp when the rule was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the rule's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the rule
				Name string `json:"name"`

				// Resource Resource this rule applies to
				Resource string `json:"resource"`

				// Service Service this rule applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the rule was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the rule
				Uuid string `json:"uuid"`
			} `json:"rule"`

			// UpdatedAt Timestamp when the role-rule binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role-rule binding
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddServiceUsersToRoleResponse parses an HTTP response from a BulkAddServiceUsersToRoleWithResponse call
func ParseBulkAddServiceUsersToRoleResponse(rsp *http.Response) (*BulkAddServiceUsersToRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddServiceUsersToRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the role binding was created
			CreatedAt time.Time `json:"created_at"`

			// Group The group the role is bound to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// Role The role that is bound
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// UpdatedAt Timestamp when the role binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role binding
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkAddUsersToRoleResponse parses an HTTP response from a BulkAddUsersToRoleWithResponse call
func ParseBulkAddUsersToRoleResponse(rsp *http.Response) (*BulkAddUsersToRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddUsersToRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []struct {
			// CreatedAt Timestamp when the role binding was created
			CreatedAt time.Time `json:"created_at"`

			// Group The group the role is bound to
			Group struct {
				// CreatedAt Timestamp when the group was created
				CreatedAt time.Time `json:"created_at"`

				// Description Optional description of the group's purpose
				Description *string `json:"description,omitempty"`

				// Name Name of the group
				Name string `json:"name"`

				// UpdatedAt Timestamp when the group was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the group
				Uuid string `json:"uuid"`
			} `json:"group"`

			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// Role The role that is bound
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// UpdatedAt Timestamp when the role binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role binding
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveRoleFromGroupResponse parses an HTTP response from a RemoveRoleFromGroupWithResponse call
func ParseRemoveRoleFromGroupResponse(rsp *http.Response) (*RemoveRoleFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRoleFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListRoleRulesResponse parses an HTTP response from a ListRoleRulesWithResponse call
func ParseListRoleRulesResponse(rsp *http.Response) (*ListRoleRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRoleRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveRuleFromRoleResponse parses an HTTP response from a RemoveRuleFromRoleWithResponse call
func ParseRemoveRuleFromRoleResponse(rsp *http.Response) (*RemoveRuleFromRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRuleFromRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAddRuleToRoleResponse parses an HTTP response from a AddRuleToRoleWithResponse call
func ParseAddRuleToRoleResponse(rsp *http.Response) (*AddRuleToRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRuleToRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServiceUsersRoleBindingsResponse parses an HTTP response from a ListServiceUsersRoleBindingsWithResponse call
func ParseListServiceUsersRoleBindingsResponse(rsp *http.Response) (*ListServiceUsersRoleBindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceUsersRoleBindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// ServiceUser The service user
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveRoleFromServiceUserResponse parses an HTTP response from a RemoveRoleFromServiceUserWithResponse call
func ParseRemoveRoleFromServiceUserResponse(rsp *http.Response) (*RemoveRoleFromServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRoleFromServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetServiceUserRoleBindingResponse parses an HTTP response from a GetServiceUserRoleBindingWithResponse call
func ParseGetServiceUserRoleBindingResponse(rsp *http.Response) (*GetServiceUserRoleBindingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceUserRoleBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// ServiceUser The service user
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAssignRoleToServiceUserResponse parses an HTTP response from a AssignRoleToServiceUserWithResponse call
func ParseAssignRoleToServiceUserResponse(rsp *http.Response) (*AssignRoleToServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the binding was created
			CreatedAt time.Time `json:"created_at"`

			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// Role The role that was assigned to the service user
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// ServiceUser The service user that was assigned the role
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// UpdatedAt Timestamp when the binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service-user-role binding
			Uuid string `json:"uuid"`

			// Workspace The workspace in which the binding exists
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListUsersRoleBindingsResponse parses an HTTP response from a ListUsersRoleBindingsWithResponse call
func ParseListUsersRoleBindingsResponse(rsp *http.Response) (*ListUsersRoleBindingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersRoleBindingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// User The user
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveRoleFromUserResponse parses an HTTP response from a RemoveRoleFromUserWithResponse call
func ParseRemoveRoleFromUserResponse(rsp *http.Response) (*RemoveRoleFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRoleFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetUserRoleBindingResponse parses an HTTP response from a GetUserRoleBindingWithResponse call
func ParseGetUserRoleBindingResponse(rsp *http.Response) (*GetUserRoleBindingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserRoleBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// User The user
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAssignRoleToUserResponse parses an HTTP response from a AssignRoleToUserWithResponse call
func ParseAssignRoleToUserResponse(rsp *http.Response) (*AssignRoleToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssignRoleToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the binding was created
			CreatedAt time.Time `json:"created_at"`

			// Items Optional items associated with this role binding
			Items interface{} `json:"items,omitempty"`

			// Role The role that was assigned to the user
			Role struct {
				// CreatedAt Timestamp when the role was created
				CreatedAt time.Time `json:"created_at"`

				// Description Description of the role's purpose and permissions
				Description *string `json:"description,omitempty"`

				// Name Name of the role
				Name string `json:"name"`

				// Service Service this role applies to
				Service string `json:"service"`

				// UpdatedAt Timestamp when the role was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the role
				Uuid string `json:"uuid"`
			} `json:"role"`

			// UpdatedAt Timestamp when the binding was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user that was assigned the role
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the user-role binding
			Uuid string `json:"uuid"`

			// Workspace The workspace in which the binding exists
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListRulesResponse parses an HTTP response from a ListRulesWithResponse call
func ParseListRulesResponse(rsp *http.Response) (*ListRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetRuleResponse parses an HTTP response from a GetRuleWithResponse call
func ParseGetRuleResponse(rsp *http.Response) (*GetRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Action Action this rule controls
			Action string `json:"action"`

			// CreatedAt Timestamp when the rule was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the rule's purpose
			Description *string `json:"description,omitempty"`

			// Name Name of the rule
			Name string `json:"name"`

			// Resource Resource this rule applies to
			Resource string `json:"resource"`

			// Service Service this rule applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the rule was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the rule
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListRuleRolesResponse parses an HTTP response from a ListRuleRolesWithResponse call
func ParseListRuleRolesResponse(rsp *http.Response) (*ListRuleRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRuleRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the role was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the role's purpose and permissions
			Description *string `json:"description,omitempty"`

			// Name Name of the role
			Name string `json:"name"`

			// Service Service this role applies to
			Service string `json:"service"`

			// UpdatedAt Timestamp when the role was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the role
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServiceUsersResponse parses an HTTP response from a ListServiceUsersWithResponse call
func ParseListServiceUsersResponse(rsp *http.Response) (*ListServiceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateServiceUserResponse parses an HTTP response from a CreateServiceUserWithResponse call
func ParseCreateServiceUserResponse(rsp *http.Response) (*CreateServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteServiceUserResponse parses an HTTP response from a DeleteServiceUserWithResponse call
func ParseDeleteServiceUserResponse(rsp *http.Response) (*DeleteServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateServiceUserResponse parses an HTTP response from a UpdateServiceUserWithResponse call
func ParseUpdateServiceUserResponse(rsp *http.Response) (*UpdateServiceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the service user was created
			CreatedAt time.Time `json:"created_at"`

			// Name Name of the service user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the service user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateServiceUserKiseKeyResponse parses an HTTP response from a CreateServiceUserKiseKeyWithResponse call
func ParseCreateServiceUserKiseKeyResponse(rsp *http.Response) (*CreateServiceUserKiseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceUserKiseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the KISE key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The KISE key content
			Key string `json:"key"`

			// ServiceUser The service user this KISE key belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Title Title or name for the KISE key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the KISE key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the KISE key
			Uuid string `json:"uuid"`

			// Workspace The workspace this KISE key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteServiceUserKiseKeyResponse parses an HTTP response from a DeleteServiceUserKiseKeyWithResponse call
func ParseDeleteServiceUserKiseKeyResponse(rsp *http.Response) (*DeleteServiceUserKiseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceUserKiseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServiceUserPublicKeysResponse parses an HTTP response from a ListServiceUserPublicKeysWithResponse call
func ParseListServiceUserPublicKeysResponse(rsp *http.Response) (*ListServiceUserPublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceUserPublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the public key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The public key content in SSH format
			Key string `json:"key"`

			// ServiceUser The service user this public key belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Title Title or name for the public key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the public key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the public key
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateServiceUserPublicKeyResponse parses an HTTP response from a CreateServiceUserPublicKeyWithResponse call
func ParseCreateServiceUserPublicKeyResponse(rsp *http.Response) (*CreateServiceUserPublicKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceUserPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the public key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The public key content in SSH format
			Key string `json:"key"`

			// ServiceUser The service user this public key belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Title Title or name for the public key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the public key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the public key
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteServiceUserPublicKeyResponse parses an HTTP response from a DeleteServiceUserPublicKeyWithResponse call
func ParseDeleteServiceUserPublicKeyResponse(rsp *http.Response) (*DeleteServiceUserPublicKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceUserPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServiceUserTokensResponse parses an HTTP response from a ListServiceUserTokensWithResponse call
func ParseListServiceUserTokensResponse(rsp *http.Response) (*ListServiceUserTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceUserTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the token was created
			CreatedAt time.Time `json:"created_at"`

			// ExpiresAt Timestamp when the token will expire
			ExpiresAt *time.Time `json:"expires_at,omitempty"`

			// Name Name of the token
			Name string `json:"name"`

			// ServiceUser The service user this token belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Uuid Unique identifier for the token
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateServiceUserTokenResponse parses an HTTP response from a CreateServiceUserTokenWithResponse call
func ParseCreateServiceUserTokenResponse(rsp *http.Response) (*CreateServiceUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the token was created
			CreatedAt time.Time `json:"created_at"`

			// ExpiresAt Timestamp when the token will expire
			ExpiresAt *time.Time `json:"expires_at,omitempty"`

			// Name Name of the token
			Name string `json:"name"`

			// Secret The secret value of the token
			Secret string `json:"secret"`

			// ServiceUser The service user this token belongs to
			ServiceUser struct {
				// CreatedAt Timestamp when the service user was created
				CreatedAt time.Time `json:"created_at"`

				// Name Name of the service user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the service user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the service user
				Uuid string `json:"uuid"`
			} `json:"service_user"`

			// Uuid Unique identifier for the token
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteServiceUserTokenResponse parses an HTTP response from a DeleteServiceUserTokenWithResponse call
func ParseDeleteServiceUserTokenResponse(rsp *http.Response) (*DeleteServiceUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListServicesResponse parses an HTTP response from a ListServicesWithResponse call
func ParseListServicesResponse(rsp *http.Response) (*ListServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the service was created
			CreatedAt time.Time `json:"created_at"`

			// Description Description of the service
			Description *string `json:"description,omitempty"`

			// Name Name of the service
			Name string `json:"name"`

			// UpdatedAt Timestamp when the service was last updated
			UpdatedAt time.Time `json:"updated_at"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkRefreshThirdPartyTokensResponse parses an HTTP response from a BulkRefreshThirdPartyTokensWithResponse call
func ParseBulkRefreshThirdPartyTokensResponse(rsp *http.Response) (*BulkRefreshThirdPartyTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkRefreshThirdPartyTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// FailedTokens Map of token identifiers to error messages for tokens that failed to refresh
			FailedTokens *map[string]string `json:"failed_tokens,omitempty"`

			// RefreshedTokens Map of token identifiers to refreshed tokens
			RefreshedTokens map[string]string `json:"refreshed_tokens"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListWorkspaceUsersResponse parses an HTTP response from a ListWorkspaceUsersWithResponse call
func ParseListWorkspaceUsersResponse(rsp *http.Response) (*ListWorkspaceUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkspaceUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromWorkspaceResponse parses an HTTP response from a RemoveUserFromWorkspaceWithResponse call
func ParseRemoveUserFromWorkspaceResponse(rsp *http.Response) (*RemoveUserFromWorkspaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAllowUserResponse parses an HTTP response from a AllowUserWithResponse call
func ParseAllowUserResponse(rsp *http.Response) (*AllowUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllowUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseListUserKiseKeysResponse parses an HTTP response from a ListUserKiseKeysWithResponse call
func ParseListUserKiseKeysResponse(rsp *http.Response) (*ListUserKiseKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserKiseKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// CreatedAt Timestamp when the KISE key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The KISE key content
			Key string `json:"key"`

			// Title Title or name for the KISE key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the KISE key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user this KISE key belongs to
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the KISE key
			Uuid string `json:"uuid"`

			// Workspace The workspace this KISE key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateUserKiseKeyResponse parses an HTTP response from a CreateUserKiseKeyWithResponse call
func ParseCreateUserKiseKeyResponse(rsp *http.Response) (*CreateUserKiseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserKiseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CreatedAt Timestamp when the KISE key was created
			CreatedAt time.Time `json:"created_at"`

			// Key The KISE key content
			Key string `json:"key"`

			// Title Title or name for the KISE key
			Title string `json:"title"`

			// UpdatedAt Timestamp when the KISE key was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// User The user this KISE key belongs to
			User struct {
				// CreatedAt Timestamp when the user was created
				CreatedAt time.Time `json:"created_at"`

				// Email Email address of the user
				Email string `json:"email"`

				// Name Full name of the user
				Name string `json:"name"`

				// UpdatedAt Timestamp when the user was last updated
				UpdatedAt time.Time `json:"updated_at"`

				// Uuid Unique identifier for the user
				Uuid string `json:"uuid"`
			} `json:"user"`

			// Uuid Unique identifier for the KISE key
			Uuid string `json:"uuid"`

			// Workspace The workspace this KISE key belongs to
			Workspace string `json:"workspace"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteUserKiseKeyResponse parses an HTTP response from a DeleteUserKiseKeyWithResponse call
func ParseDeleteUserKiseKeyResponse(rsp *http.Response) (*DeleteUserKiseKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserKiseKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseSuspendUserResponse parses an HTTP response from a SuspendUserWithResponse call
func ParseSuspendUserResponse(rsp *http.Response) (*SuspendUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreatedAt Timestamp when the user was created
			CreatedAt time.Time `json:"created_at"`

			// Email Email address of the user
			Email string `json:"email"`

			// Name Full name of the user
			Name string `json:"name"`

			// UpdatedAt Timestamp when the user was last updated
			UpdatedAt time.Time `json:"updated_at"`

			// Uuid Unique identifier for the user
			Uuid string `json:"uuid"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetOpenIdTokenResponse parses an HTTP response from a GetOpenIdTokenWithResponse call
func ParseGetOpenIdTokenResponse(rsp *http.Response) (*GetOpenIdTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenIdTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken OAuth 2.0 access token
			AccessToken string `json:"access_token"`

			// ExpiresIn Number of seconds until the token expires
			ExpiresIn int `json:"expires_in"`

			// IdToken OpenID Connect ID token
			IdToken *string `json:"id_token,omitempty"`

			// RefreshToken OAuth 2.0 refresh token
			RefreshToken *string `json:"refresh_token,omitempty"`

			// TokenType Type of token, typically 'Bearer'
			TokenType string `json:"token_type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Code    int `json:"code"`
			Message struct {
				Detail string `json:"detail"`
			} `json:"message"`
			Reason string `json:"reason"`
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}
